class Solution {
    private int lastocc(String s, Character c){
        for(int i=s.length()-1;i>=0;i--){
            if(s.charAt(i)==c) return i;
        }
return -1;
    }
    public List<Integer> partitionLabels(String s) {
        List<Integer> partition = new ArrayList<>();

        int i = 0;
        while (i < s.length()) {
            int start = i;
            int last = lastocc(s, s.charAt(i));

            for (int j = start + 1; j <= last; j++) {
                int lon = lastocc(s, s.charAt(j));
                if (lon > last) {
                    last = lon;
                }
            }

            partition.add(last - start + 1);
            i = last + 1;  
        }

        return partition;
    }
}
/* class Solution {
    public List<Integer> partitionLabels(String s) {
        // Step 1: Preprocess - store the last occurrence index of each character
        // This takes O(n) time and O(1) space (only 26 lowercase letters)
        int[] lastIndex = new int[26];
        for (int i = 0; i < s.length(); i++) {
            lastIndex[s.charAt(i) - 'a'] = i;
        }
        
        List<Integer> partitions = new ArrayList<>();
        int start = 0;      // Start of current partition
        int end = 0;        // End of current partition
        
        // Step 2: One pass through the string to build partitions
        for (int i = 0; i < s.length(); i++) {
            // Extend the partition boundary if current character's 
            // last occurrence is beyond current end
            end = Math.max(end, lastIndex[s.charAt(i) - 'a']);
            
            // If we've reached the end of the partition
            if (i == end) {
                // Add partition size and start new partition
                partitions.add(end - start + 1);
                start = i + 1;
            }
        }
        
        return partitions;
    }
} */
