Leetcode 

So we have phases planned 
Phase 1-2: 220 problems (Array + String fundamentals)
Phase 3: 100 problems (LinkedList + Stack/Queue)
Phase 4: 100 problems (HashMap + Binary Search)
Phase 5: 100 problems (Heap + Tree basics)
Phase 6: 80 problems (BST + Graph algorithms)

PHASE 1
Phase 1: Array Patterns (1-120)
A. Array Basics - Pure Easy (1-20)
B. Two Pointers - Gradual Complexity (21-40)
C. Sliding Window - Step by Step (41-70)
D. Prefix Sum & Array Math (71-95)
E. Advanced Array Techniques (96-120)
Phase 2: String Patterns (121-220)
A. String Fundamentals (121-145)
B. Pattern Matching - Easy to Medium (146-170)
C. Advanced String Algorithms (171-195)
D. String DP & Complex Patterns (196-220)
Phase 3: LinkedList Patterns (221-320)
A. LinkedList Fundamentals (221-245)
B. Advanced LinkedList Operations (246-270)
C. Stack Fundamentals (271-295)
D. Queue & Deque Patterns (296-320)
Phase 4: HashMap & Binary Search (321-420)
A. HashMap Fundamentals (321-350)
B. Advanced HashMap Patterns (351-375)
C. Binary Search Fundamentals (376-400)
D. Advanced Binary Search (401-420)
Phase 5: Heap & Tree Fundamentals (421-520)
A. Heap Operations (421-450)
B. Tree Traversals (451-475)
C. Tree Properties & Validation (476-500)
D. Path & Sum Problems (501-520)
Phase 6: BST & Graph Algorithms (521-600)
A. Binary Search Tree Operations (521-545)
B. Graph Traversal & Basic Algorithms (546-570)
C. Advanced Graph Algorithms (571-590)
D. Final Integration & Complex Problems (591-600)















A. Array Basics - Pure Easy (1-20)
1. Running Sum of 1d Array â€” 1480 (Basic iteration)
2. Find Numbers with Even Number of Digits â€” 1295 (Digit counting)
3. Max Consecutive Ones â€” 485 (Simple counting)
4. Squares of a Sorted Array â€” 977 (Two pointers intro)
5. Duplicate Zeros â€” 1089 (Array modification)
6. Merge Sorted Array â€” 88 (Two array merging)
7. Remove Element â€” 27 (In-place removal)
8. Remove Duplicates from Sorted Array â€” 26 (Two pointers)
9. Check If N and Its Double Exist â€” 1346 (HashSet usage)
10. Valid Mountain Array â€” 941 (Single pass validation) 
11. Replace Elements with Greatest Element on Right Side â€” 1299 (Right-to-left)
12. Move Zeroes â€” 283 (Two pointers with zeros)
13. Sort Array By Parity â€” 905 (Partitioning)
14. Sort Array By Parity II â€” 922 (Even/odd positioning)
15. Height Checker â€” 1051 (Comparison with sorted)
16. Third Maximum Number â€” 414 (Set for top elements)
17. Find All Numbers Disappeared in an Array â€” 448 (Array as hash)
18. Single Number â€” 136 (XOR properties) 
19. Majority Element â€” 169 (Boyer-Moore or counting)
20. Contains Duplicate â€” 217 (HashSet detection)


Question1. Running Sum of 1d Array â€” 1480 (Basic iteration)
Question2. Find Numbers with Even Number of Digits â€” 1295 (Digit counting)
SOLUTION) There could be many ways to do it 
1)String Conversion
String.valueOf(int i) actually calls Integer.toString(i) behind the scenes
int count=0;
       for(int i=0; i<nums.length;i++){
           if(String.valueOf(nums[i]).length()%2==0){
               count++;
2) Counting Digits
By counting digits until the quotient of that number is not equal to zero  
single digit/10 ==0

3)Using Math (log)
Number of digits = floor(logâ‚â‚€(number)) + 1       just think int terms of log basics

int digits= (int)(Math.log10(nums[i]))+1;

4)Question specific constraints trick
5)Bit manipulation
THESE BOTH WILL BE COVERED LATER
Question3. Max Consecutive Ones â€” 485 (Simple counting)

We simply iterate and check if element is zero then the streak ends and we update streak using Math.max

Question4. Squares of a Sorted Array â€” 977 (Two pointers intro)
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
So the problem here is the negative integers everything is already sorted so the TRICK  here is after squaring we need TWO pointers 
     

[-7,-3,2,3,11]  this becomes [49, 9, 4, 9 , 121]  so between there somewhere there is a point around which everything is already sorted something like [49, 9,(that point) 4, 9 , 121]
 So we use two pointers a start and an end pointer and sort the array by shifting them 

Question5. ðŸ”¥Duplicate Zeros â€” 1089 (Array modification)

Main idea is we go from right to left, we have imaginary pointer which exceeds the array length and we just write when its within range.
Step1) Count no of zeros/extra elements
Step2) we traverse right to left and simply shift each element if j<n & if the lament is zero we shift the j pointer left once and write a zero again 

Things to remember in this code is 
First we use index to shift all elements
Second if the number is zero we shift one left and and write zero

Question6. Merge Sorted Array â€” 88 (Two array merging)
We will have three pointers one for first reading array, one for reading second , third for writing first, simply compare elements, then place, thing to remember here is the first array can be fully read before the second so then we will need to check if any left in second array and have ablock like 
while(j >= 0) {
           nums1[k] = nums2[j];
           k--;
           j--;
       }

Question7. Remove Element â€” 27 (In-place removal)
We have one pointer that reads/iterate through array and checks the what elements are not equal to value, and then we have another pointer for writing the elements.
Question8. Remove Duplicates from Sorted Array â€” 26 (Two pointers)
 Again two pointers, one pointer reads the array , here the condition is as it is ascending order you just need to check if right element is greater than the left element also what we then just switch the element with the other one 

Question9. Check If N and Its Double Exist â€” 1346 (HashSet usage)
             Brute force simple â€“ two for loops and check for each element if next exists 
             Hashmap â€“ make a hashmap add with key as element and index as value 
		Then simply check through containskey (function) if 2*element exists and the                                                
                        index is not equal to i
             Hashset â€“ make an hashset so here the thing to remember is first we check and if it   
                            doesn't exists then we add, so the flow is like 
First make a hashset
Check if the nums*2 exists and have another || condition (nums%2 =0 && set.contains(nums/2) return true
Else add the nums to set

Question 10. Valid Mountain Array â€” 941 (Single pass validation) 
 So the way to think here is think about peak, there will a increasing side and an decreasing side, have two pointers and increase one if the elements are increasing and decrease one (from the end) if its decreasing from the other, if they meet at the same its a peak.
Things to consider edge cases - peak is not on one of the ends for example the first element or the last 
Question 11. Replace Elements with Greatest Element on Right Side â€” 1299 (Right-to-left)
	Brute force- for left to right, check the greatest for each element and then update each        
                                element 
Optimal - Go from right to left and have a variable that keeps track of the max element and the question in my mind was how are we going to tackle the update and still read problem so we simply make a variable to check 
Question 12. Move Zeroes â€” 283 (Two pointers with zeros)
Simply have two pointers one to iterate through (using the for loop) and have one pointer that just holds the position of the zeros that we need to make a switch here and then we have a temp variable to make the switch 
Question 13. Sort Array By Parity â€” 905 (Partitioning)
We have two pointers one at start and one at end then we will have 4 cases 
	Odd , even then we swap i++,jâ€“
	Even, odd then we do nothing j- -
	Odd, odd we do nothing  i++
	odd , even we do nothing j - -
Question 14. Sort Array By Parity II â€” 922 (Even/odd positioning)
           I=0 AND J =1  and we check if i is even do nothing i+=2 similarly for j check if odd and increment by 2 places and then at the end of each for loop simply swap 
So how it looks is 
One while loop
	while(i condition)
	while(j condition)
	if(i & j both in bounds)
		Swap

Question 15. Height Checker â€” 1051 (Comparison with sorted)
	So we simply make a new array and then we clone and sort array using int sorted[] = heights.clone();Arrays.sort(sorted);
After that we have a simple for loop and check if each element is equal, if not counter increment and return counter 

Question 16. Third Maximum Number â€” 414 (Set for top elements)
	Basic approach- turn array to set, set to array then sort and give the max 			      
            Use collections-                                         Set<Integer> set = new HashSet<>();
        for(int num: nums) set.add(num);
        if(set.size()<3) return Collections.max(set);
        set.remove(Collections.max(set));
        set.remove(Collections.max(set));
        return Collections.max(set);
	Use TreeSet/ordered set
	Use Three variables 


Question 17. Find All Numbers Disappeared in an Array â€” 448 (Array as hash)
Brute force - have 2 for loops, we just find if the number is present if present ok , if not and to check use this condn  if(i == nums.length){ missing.add(number);
If not present simply add in arraylist

Inplace mark negative- simple for each element mark that indexâ€™s element as negative then when that element is not negative add the element

Question 18. Single Number â€” 136 (XOR properties) 
	So XOR is like only true when both bits are different , so what we can do here take xor of all the elements, rest of the elements will automatically become 0 and we will only be left with the distinct number.
And for implementationâ€™s purpose we will start from 0 as xor of any number with zero is number itself.
4 â†’ 0100
0 â†’ 0000      
            4 XOR 0 â†’ 0100    
So if we have an array like [4,2,1,2,1]    4^2^1^2^1 â†’ 4^0^0 â†’ 4^0 â†’ 4    


Question 19. Majority Element â€” 169 (Boyer-Moore or counting)
Brute â†’ for loop ek ke andr ek , for each count kro total if occurrence > n/2 return number.
Hashmap â†’ hashmap me daldo use getorDefault, same n/2 ka khel
Sort and give middle Approach   sorry and give n/2th element
Booyre Moore Voting â†’ have a candidate(current) for each occurrence add to its count and when the count is zero , change the candidate and at the end of the array, whichever candidate is current is the majority or winning candidate.
Bit manipulation â†’ count the the number of 1s in each position for each element , and on basis of that judge what is the numbers bits , also we need to do 32 bits as integer is 32 bits long


Question 20. Contains Duplicate â€” 217 (HashSet detection)
Simply add to hashset and check if length is equal or not 
Sort and check adjacent 
Add to hashmap if value for any key greater than 1, return duplicate 
Streams, convert to streams, 
	return Arrays.stream(nums)
             .distinct()
             .count() != nums.length;

Question 21. Best Time to Buy and Sell Stock â€” 121 (Single pass min tracking)
Brute force - check profit for each element towards all the elements to the right, simple nested for loops technique
Another approach is kind of clever , so we have use elements as as iteration , then we find minvalue we encountered till now, then we have a maxprofit , a profit
We check the profit from mintillnow and calculate profit and then compare it with maxprofit
class Solution {
   public int maxProfit(int[] prices) {
     
       int mintillnow =Integer.MAX_VALUE;
       int maxprofit=0;
       for(int price :prices){
           mintillnow =Math.min(mintillnow,price);
           int profit = price- mintillnow;
           maxprofit=Math.max(profit,maxprofit);
       }
       return maxprofit;
   }
}
 

Question  22. Find Pivot Index â€” 724 (Left vs right sum)
	So what we can do is have the total and calculate right and left sum towards each element and compare the numbers right sum = total - left sum - current element 
If ls == rs return i and if they not return -1;
Question  23. Pascal's Triangle â€” 118 (Row generation)
So the left and right most elements are 1 and rest ith term are the sum of previous rows (i-1)th + (i)th term 

So the tactical thing is we create a list of integers, and then add this list for each iteration to a list of list of integers that we are gonna return 


Question  24. Pascal's Triangle II â€” 119 (Space optimized)
Same ;like previous but we need a more optimized solution these all are o(n^2)
So a better approach is using the combinations formula, where i be the row and k be the element then iCk is the kth element 
And the tactical deplyement is like 
nC(k+1) = nCk Ã— (n-k) / (k+1)    Get next value from current
nCk = nC(k-1) Ã— (n-k+1) / k		Get current from previous (used in code)
Question  25. Find All Duplicates in an Array â€” 442 (Array as hashmap)
So the problem here says that there should be linear space utilization so the problem is when we use hashmaps, hashsets, sorting those approaches cant follow the restrain , so what we can do instead is marking the index or elements as negative , so an algorithm like 
Step1)having a list named result
Step2)calculate index 
Step3)check if nums[index] is negative
	If yes then add to result\
	In not , make the element negative

Question 26. Reverse String â€” 344 (Two pointers swap)
Simply use two pointers, one at the strating end, other at the other end, and simply use a temp and swap elements
Question  27. Valid Palindrome â€” 125 (Two pointers validation)
SO tactical points here are just use while(l<r && !Character.isLetterOrDigit(s.charAt(l))) l++
And then just checking if charAt(l) is equal to charAt(r)
Question 28. Remove Duplicates from Sorted Array II â€” 80 (Count-based removal)
So basically what we trying to have 2 pointers and we have one reading index that is a for loop, then we have a write index and we compare the writeindex-2 simply if the readindex is not equal to writeindex-2 we update the write and simply ++the write index 
Question 29. Two Sum II - Input Array Is Sorted â€” 167 (Two pointers sum)
As the array is in ascending order what we can do is have two pointers one at start and the other at end and simply return the index if sum is equal to target and if this is not the case then what we can do is compare the sum and target and accordingly  move left, right index 
Question 30. Reverse Vowels of a String â€” 345 (Conditional swap) (nice question)
SO first thing first strings are immutable so convert to array use char[] arr =s.toCharArray();
Next tactical thing is we need to check if a character is vowel we simply create a string named , vowel and then use vowels.indexOf(arr[i])==-1) 
And then we simply swap and i++,j--   

Question 31. Intersection of Two Arrays â€” 349 (Set intersection)
Have two sets first set add the nums1 and then in second set only add elements that are present both in nums1 and nums2 and at the end we convert the set to an array using streams return result.stream().mapToInt(i -> i).toArray

Question 32. Container With Most Water â€” 11 (Two pointers greedy)
Have two pointers, left and right and simply calculate width=right-left ; height=Math.min(height[l],height[r])
For two pointers which ever of left and right pointerâ€™s height is smaller move that 

Question 33. 3Sum â€” 15 (Sorted two pointers)
First we sort the array, we sort it so we have a sense of directional order that way we can manipulate it.
THEN we have three pointers i(an outer loop)
J as i+1 for each iteration, then k as length-1  
We check if nums[j] +nums[k] = target(ie. -nums[i])
Then we check if sum(ie. nums[j]+sums[k])   if sum<target then j++ because array is sorted   Else k--  
Also other important thing is we dont want duplicates in the result so we put a conditionFor i at the start of for loop  if(i>0 && nums[i-1]==nums[i]) continue;
Then two while loops for j & k if(j<k && nums[j-1]=nums[j] j++;
if(j<k && nums[k]=nums[k+1] k--;
Question 34. 3Sum Closest â€” 16 (Distance optimization)
Same like previous question have 3 pointers same technique only this time the difference is we need to find closest so we take abs difference and then play accordingly , have a current sum and a closest sum comparing them updating them 








Question35. Sort Colors â€” 75 (Dutch flag partition)

Main idea is we have three pointers as boundaries all 0â€™s right to low 
To whenever nums[mid]=0 here swap low and mid element mid, low++
If mis=1 mid++
If mid==2 swap aur sirf high--   matlab us element ko mid ke right me daldiya 
So three pointers but think the range of those we have some thing like 


low=0;mid=0;high=n-1;
Elements sirf 0,1,2 hi honge , to apn mid se khele khel 
if(nums[mid]==0)  should be then swap nums[mid] and nums[low] because 0 should be right of low and we mid++ and low++
if(nums[mid]==1) to simply mid++
else(nums[mid] ==2) swap nums[mid] and nums[high] and mid++ and high -- 
 

Question36. Valid Triangle Number â€” 611 (Triangle inequality)
So basically we sort the array, the idea behind sorting is to be able to play with the longest side so we simply loo[pp around the longest side 
If sum of smaller sides is longer than the longest side then it is a triangle , so the thing is array is sorted so all the combinations from i to j which are (j-i) ways of triangles 
To count =+j-i; jâ€“;
Else i++;

Question 37. Boats to Save People â€” 881 (Greedy pairing)
Apnne sort krlena hai, fir simple best case if heaviest goes with lightest if possible if not heaviest goes by himself.
if(heavy+light)<=limit;{
Light++;}
heavy--  ; heavy always going in a boat;
Boats++; 





Question 38. Bag of Tokens â€” 948 (Two pointers strategy)

Jha bhi greedy abhi tak , bas sort krdo array tbhi you can use it greedily. 
Most greedy approach hogi sort krke cheapest token se score khredna (FACEUP)that means l, (FACEDOWN) me greedy hoga score tab spent jab token[h] max . 

	
Sliding Window Introduction (39â€“52)
Question 39. Maximum Average Subarray I â€” 643 (Fixed window sum)
Dont always think in two pointer, for a window if its length is fixed we not need to have two pointers for each of its boundaries, instead use the length of the window.
Calculate sum of first window, then just add next element to sum and then remove previous 
Question  40. Minimum Difference Between Highest and Lowest of K Scores â€” 1984 (Sorted sliding window)
First sort the array, that way we already know the highest and lowest for k numbers, then we simply subtract and see what is min diff
Question  41. Grumpy Bookstore Owner â€” 1052 (State-based window)
First find all the satisfied customers , now the problem is if we could flip as many not satisfied to satisfied(ie is non grumpy), we basically need to maximize the number of unsatisfied customers.
Then we simply add satisfied and the maxunsatisifed customers in that k minutes of time, using the window 
Question 42. Max Consecutive Ones III â€” 1004 (Window with K flips)(thoda yaad rkne type ka hai)
Variable pointer windows apan a lot of times solve by 2 pointers with sliding window 
Have two pointer land r , r iterates the array and first we expand the array until max zeros possible , after that we start to shift left pointer 
Question 43. Longest Substring Without Repeating Characters â€” 3 (Variable window)
	Actual trick is using hashmap, 
Two pointer chalane hai teji se, sliding window bhi hai but sirf contextual/pragmatism of problem, otherwise computation me khi bhi ye involved nhi hai         l,r=0;
To trick is jab aisa element mile jo already in hashmap hai,l ko update in such a way that last appearance +1; index  so l =map.get(c) +1;, fir maxlength math.max se update krte rhte .length of current window=l-r+1

Question 44. Minimum Size Subarray Sum â€” 209 (Shrinkable window)
Simply ek left aur right pointer ho , right se sum lete jao , aur jab sum bada hojaw target se tab , then ek while loop jo l++ karta jae and check krta jae minlen
Question 45. Longest Repeating Character Replacement â€” 424 (Character frequency)
So the trick here is that we can switch atmost k times, and any valid substring would be lengthofwindow - mostfrequentelement <k , if not we simply move the left pointer towards right
Question 46. Fruit Into Baskets â€” 904 (Two distinct elements)tricky implementation 
Same concept of window, things to consider is how you move window and what condition you apply
So window has l and r , we move r to read array at every iteration, move l++ when map.size>k , and update value of map.get(leftfruit)-1;remove if map.get(lf) ==0
And update maxtree len, by math

Question 47. Permutation in String â€” 567
Have two arrays for freq counting one for s1 and one for a window of len =s1(we try to maintain it to s1)
Populate s1count, populate windowcount with s2 such that if element or i of s2 is >=s1.len
Freq of leftmost -- in windowcount array, then if both arrays are equal return tru otherwise false
Question 48. Find All Anagrams in a String â€” 438 (All anagram positions)
Whenever we want to find if a stringâ€™s some permutation is present or not we can simply think of frequency arrays for each of the string , this is same like previous questions ,
We again simply decrease the frequency of the leftmost element when window is getting longer than p.length() and at the end simply use if Arrays.equal(array1, array2)
Question 49. Longest Substring with At Most Two Distinct Characters â€” 159 (K=2 distinct)
So the questions is like the final substring must have 2 distinct characters, simply think of a hashmap and use the technique every time a new element appears to right we reduce the count in hashmap as soon as the count of the left element zero remove it , but we always will shift left point to right
Main point is understanding that hashmap length represents the number of distinct elements
Question 50. Longest Substring with At Most K Distinct Characters â€” 340 (Generalized K distinct)
Same like last problem main thing, is that theres a hashmap whose length is distinct ele,
We havea left and a right pointer , we move right and put it in hashmap, fir agr more than or k elements hojae jab hasmap to left wla ++ krke uska count decrease 

Question 51. Subarrays with K Different Integers â€” 992 (Exact K distinct)
This problem is also similar to previous ones, we simply calculate maximum number of substrings/subarrays present, for example we calculate atmost 3 it include with 1, 2 elem
So we simple subtract with atmost(k)-atmost(2) == with(k)
Question 52. Longest Subarray of 1's After Deleting One Element â€” 1493 (One deletion allowed)
So we are trying to find the longest window with utmost one zero.
We go by solving it such that if number of zeros is greater than 1 , we shift left pointer 




HashMap Fundamentals (53â€“68)
Question 53. Two Sum â€” 1 (Classic hashmap)
Simple use hashmap, have a compliment , so what are we trying to add in hashmap, element and its index, so for current element if we have its compliment then return the that i and the compliments(the other elements) index 
Question 54. Valid Anagram â€” 242 (Frequency counting)
Two frequency arrays , like a to z each element representing an alphabet

Question 55. Contains Duplicate III â€” 220 (Value and index constraint)
Either use a bucket sort , we used treeset (o of nlogk), so the idea is to use floor and ceiling, we simply calculate the floor.
We have two if conditions one for floor where we check floor is not null and if num- floor <= valuediff and similarly for the ceiling.
And the sliding window part sixmply , agr i>indexdiff to remove (i-indexdiff) or the element outside the scope.USE LONG
Question 56. Intersection of Two Arrays II â€” 350 (Frequency map)
To apn frequency array use krenge ,create them , populate them and then compare fir utti baar print krdo 
Print krne ka logic, 
Ek for loop ke andr ek aur , but ye n^2 complexity nhi hai , o of n for some reason most probably because of input or some logic 
Question 57. First Unique Character in a String - 387 (Frequency + order)
Simply use a freq array or a hashmap,
Step 1)populate the array/hashmap
Step 2)simply ek for loop, jiska pehla 1 agya , wo answer i
Question 58. Ransom Note â€” 383 (Character availability)
Simply use frequency arrays and then if frequency of each element/alphabet for ransomnote is less than magazine return false, else return true;
Question 59. Isomorphic Strings â€” 205 (Character mapping)
So what we do is we remember the first occurance of characters for the strings, if they are not equal return false 
Question 60. Word Pattern â€” 290 (Bijection mapping)
Whenever dealing with hashmap remember we mostly check if something is not present if we try and see something is present what happens is the first time we encounter it we return a true and its broken because we dont parse rest of the array 

So here we plan to have to Hashmap one chartoword and the other wordtochar, we then check if chartoword maps to that word and wordtochar maps to that character. 
Question 61. Group Anagrams â€” 49 (Signature grouping)
TO scene aisa hai, ek hashmap banae of <String,list<String>> ka, fir each element ko sort krke ,usko arralist me add krte jae, also java me string immutable hoe, to apn kya krte convert it to an array of char[] chars = stringname.toCharArray()); fir sort krke convert 
Question 62. Happy Number â€” 202 (Cycle detection)
So the thing is when we do the happy number check again and again, a loop is formed ,
We can check this loop by two methods 
USE a set, if its a set the loop doesnt infinite as the number of duplicates are eliminated 
USE two pointer, one fast and one slow=n, fast=nextnum(slow/n);
Fir if fast pointer is equal to slow , false but code krna hai opposite code kaise likhoge
while (fast != 1 && slow != fast) {
           slow = getNext(slow);
           fast = getNext(getNext(fast));
       }
      
       return fast == 1;



Question 63. Contains Duplicate II â€” 219 (Index tracking)
Have a hashmap with the element as key and index as value, if map contains the element and i-that index<= k , then return true , else add the element to the map
Question 64. Longest Harmonious Subsequence â€” 594 (Adjacent frequencies)
Have a hashmap , populate it with the elements and their frequencies , then use map.Keyset() and in a for loop check if hashmap has ele+1;  then add them and give maxlen using Math
Question 65. Degree of an Array â€” 697 (Frequency + range)
So here the approach is for every element we need to keep in account, three things , count/frequency , first appearance, last appearance. We use three hashmaps to keep track of them.After that for all elements whose count == degree , we calculate window r-l+1;
We use int degree=Collections.max(count.values()); to find degree 
         For syntactical finesse   for(Integer num : count.keySet()){

Question 66. Set Mismatch â€” 645 (Duplicate + missing)
We simply have a hashmap record everything, then have a for loop if something missing add it as missing, if somevalue is 2 add it as duplicate and return ,

You can also use a array as the length , nums[i] is ok not too big , something similar to a frequency array
Question 67. Valid Sudoku â€” 36 (Multiple sets)
Matrix dekhke bharbharae nhi, simply ek set kre of strings, aur har ek element ko unique 
Do for loop ho ,kaise banae , ek element ko teen tareeke se store kre rowâ†’ c + â€œin rowâ€ + i
Colâ†’ c + â€œin colâ€ + j    boxâ†’ c + â€œin boxâ€ + i/3 + â€œ-â€ + j/3
Ok ab agr new element me kuch bhi contains hoga to false either add
Question 68. Logger Rate Limiter â€” 359 (Time-based hashmap)




Prefix Sum Pattern (69â€“78)
Question 69. Range Sum Query - Immutable â€” 303 (Prefix sum query)
Constructor, method, class, ye sab samjh nhi arhe hai sahi se, logic is ok
Ki prefix sum calculate krlo ki prefix[0]=nums[0], fir prefix[i]=prefix[i-1]+nums[i];
Fir return ke time if left==0 return prefix[right]
Else prefix[right]-prefix[left-1] because l and r inclusive chiaye
Question 70. Range Sum Query 2D - Immutable â€” 304 (2D prefix sum)

class NumMatrix {
  
   private int[][] prefix;
   public NumMatrix(int[][] matrix) {
       int m=matrix.length;
       int n=matrix[0].length;
       prefix = new int[m][n];
       for(int i=0;i<m;i++){
           prefix[i][0]=matrix[i][0];
           for(int j=1;j<n;j++){
               prefix[i][j]=prefix[i][j-1]+matrix[i][j];
           }
       }
  
   }
  
   public int sumRegion(int row1, int col1, int row2, int col2) {
       int sum=0;
       for(int i=row1;i<=row2;i++){
           int leftprefix=0;
           if(col1>0){
               leftprefix=prefix[i][col1-1];
           }
           else{
               leftprefix=0;
           }
           sum+=prefix[i][col2]-leftprefix;


       }
       return sum;
   }
}


Question 71. Matrix Block Sum â€” 1314 (2D range query)
Same whoi matrix ka presum bnaya fir, answer/sum calculate krne ke liye , logic lgado , logic copy pe jaega , fir whi row wla for loop lgana
Question 72. Product of Array Except Self â€” 238 (Prefix/suffix products)
Total product lele, fir 3 cases hai main, agr â€ wo  0 then then all elements are 0, if 1 elelement only element with 0 gets product, if no eros simple pro/nums[i]
Question 73. Subarray Sum Equals K â€” 560 (Prefix sum + hashmap)
So we use prefix and the condition is prefix[r]-prefix[l-1]=k, when ith element is inclusive 
We can say prefix[r] -k =prefix[l-1]  , we use a hashmap<prefix, frequency> and say if we find the prefix[r]-k then it is a valid subarray.also we move from left to right so we have all previous possible combinations
Question 74. Continuous Subarray Sum â€” 523 (Modulo prefix sum)
Think similarly we are trying to find (prefix[r]-prefix[l])%k==0, this can also mean 
prefix[r]%k==prefix[l-1]%k
Bas fir who hashmap, if found then valid subarray does exists 

Question 75. Subarray Sums Divisible by K â€” 974 (Modulo handling)
Same to previous question same technique only thing unique here is we need to somehow accommodate the negative remainders so we use 
int curr=((prefix[i]%k)+k)%k;
And we play usong frequency 
Question 76. Contiguous Array â€” 525 (Transform to sum problem)
So its a binary array and we need to find equal number of 1 and 0 , so sum =0;
We convert 0s to -1s , prefix me prefix[i]=prefix[i-1]+((nums[i]==0) ? -1:1);
And simply agr koi i ke liye current=prefix[i] apn dekh chuke to uss wo ek valid window hogyi, after that what we do is windowlength= i-map.get(current) fir just measure maxlen

Question 77. Maximum Size Subarray Sum Equals k â€” 325 (Longest subarray)
Same hi hai 

Question 78. Subarray Product Less Than K â€” 713 (Product constraint)
Sliding window use krenge, l,r=0;
Ek for loop se product calculate aur fir use for loop ke andr ek while(pro>=k) to l++;
Main part is count=r-l+1;
Ek subarray [1,2,3,4] whose indexes looks like [5,6,7,8] r=8;l=5 count=8-5+1=4 windows which are â†’ [5,6,7,8] ; [6,7,8] ; [7,8] ; [8]   so 4 possible windows ending with the last element.



