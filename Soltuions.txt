Leetcode 

So we have phases planned 
Phase 1-2: 220 problems (Array + String fundamentals)
Phase 3: 100 problems (LinkedList + Stack/Queue)
Phase 4: 100 problems (HashMap + Binary Search)
Phase 5: 100 problems (Heap + Tree basics)
Phase 6: 80 problems (BST + Graph algorithms)

PHASE 1
Phase 1: Array Patterns (1-120)
A. Array Basics - Pure Easy (1-20)
B. Two Pointers - Gradual Complexity (21-40)
C. Sliding Window - Step by Step (41-70)
D. Prefix Sum & Array Math (71-95)
E. Advanced Array Techniques (96-120)
Phase 2: String Patterns (121-220)
A. String Fundamentals (121-145)
B. Pattern Matching - Easy to Medium (146-170)
C. Advanced String Algorithms (171-195)
D. String DP & Complex Patterns (196-220)
Phase 3: LinkedList Patterns (221-320)
A. LinkedList Fundamentals (221-245)
B. Advanced LinkedList Operations (246-270)
C. Stack Fundamentals (271-295)
D. Queue & Deque Patterns (296-320)
Phase 4: HashMap & Binary Search (321-420)
A. HashMap Fundamentals (321-350)
B. Advanced HashMap Patterns (351-375)
C. Binary Search Fundamentals (376-400)
D. Advanced Binary Search (401-420)
Phase 5: Heap & Tree Fundamentals (421-520)
A. Heap Operations (421-450)
B. Tree Traversals (451-475)
C. Tree Properties & Validation (476-500)
D. Path & Sum Problems (501-520)
Phase 6: BST & Graph Algorithms (521-600)
A. Binary Search Tree Operations (521-545)
B. Graph Traversal & Basic Algorithms (546-570)
C. Advanced Graph Algorithms (571-590)
D. Final Integration & Complex Problems (591-600)















A. Array Basics - Pure Easy (1-20)
1. Running Sum of 1d Array â€” 1480 (Basic iteration)
2. Find Numbers with Even Number of Digits â€” 1295 (Digit counting)
3. Max Consecutive Ones â€” 485 (Simple counting)
4. Squares of a Sorted Array â€” 977 (Two pointers intro)
5. Duplicate Zeros â€” 1089 (Array modification)
6. Merge Sorted Array â€” 88 (Two array merging)
7. Remove Element â€” 27 (In-place removal)
8. Remove Duplicates from Sorted Array â€” 26 (Two pointers)
9. Check If N and Its Double Exist â€” 1346 (HashSet usage)
10. Valid Mountain Array â€” 941 (Single pass validation) 
11. Replace Elements with Greatest Element on Right Side â€” 1299 (Right-to-left)
12. Move Zeroes â€” 283 (Two pointers with zeros)
13. Sort Array By Parity â€” 905 (Partitioning)
14. Sort Array By Parity II â€” 922 (Even/odd positioning)
15. Height Checker â€” 1051 (Comparison with sorted)
16. Third Maximum Number â€” 414 (Set for top elements)
17. Find All Numbers Disappeared in an Array â€” 448 (Array as hash)
18. Single Number â€” 136 (XOR properties) 
19. Majority Element â€” 169 (Boyer-Moore or counting)
20. Contains Duplicate â€” 217 (HashSet detection)


Question1. Running Sum of 1d Array â€” 1480 (Basic iteration)
Question2. Find Numbers with Even Number of Digits â€” 1295 (Digit counting)
SOLUTION) There could be many ways to do it 
1)String Conversion
String.valueOf(int i) actually calls Integer.toString(i) behind the scenes
int count=0;
       for(int i=0; i<nums.length;i++){
           if(String.valueOf(nums[i]).length()%2==0){
               count++;
2) Counting Digits
By counting digits until the quotient of that number is not equal to zero  
single digit/10 ==0

3)Using Math (log)
Number of digits = floor(logâ‚â‚€(number)) + 1       just think int terms of log basics

int digits= (int)(Math.log10(nums[i]))+1;

4)Question specific constraints trick
5)Bit manipulation
THESE BOTH WILL BE COVERED LATER
Question3. Max Consecutive Ones â€” 485 (Simple counting)

We simply iterate and check if element is zero then the streak ends and we update streak using Math.max

Question4. Squares of a Sorted Array â€” 977 (Two pointers intro)
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
So the problem here is the negative integers everything is already sorted so the TRICK  here is after squaring we need TWO pointers 
     

[-7,-3,2,3,11]  this becomes [49, 9, 4, 9 , 121]  so between there somewhere there is a point around which everything is already sorted something like [49, 9,(that point) 4, 9 , 121]
 So we use two pointers a start and an end pointer and sort the array by shifting them 

Question5. ðŸ”¥Duplicate Zeros â€” 1089 (Array modification)

Main idea is we go from right to left, we have imaginary pointer which exceeds the array length and we just write when its within range.
Step1) Count no of zeros/extra elements
Step2) we traverse right to left and simply shift each element if j<n & if the lament is zero we shift the j pointer left once and write a zero again 

Things to remember in this code is 
First we use index to shift all elements
Second if the number is zero we shift one left and and write zero

Question6. Merge Sorted Array â€” 88 (Two array merging)
We will have three pointers one for first reading array, one for reading second , third for writing first, simply compare elements, then place, thing to remember here is the first array can be fully read before the second so then we will need to check if any left in second array and have ablock like 
while(j >= 0) {
           nums1[k] = nums2[j];
           k--;
           j--;
       }

Question7. Remove Element â€” 27 (In-place removal)
We have one pointer that reads/iterate through array and checks the what elements are not equal to value, and then we have another pointer for writing the elements.
Question8. Remove Duplicates from Sorted Array â€” 26 (Two pointers)
 Again two pointers, one pointer reads the array , here the condition is as it is ascending order you just need to check if right element is greater than the left element also what we then just switch the element with the other one 

Question9. Check If N and Its Double Exist â€” 1346 (HashSet usage)
             Brute force simple â€“ two for loops and check for each element if next exists 
             Hashmap â€“ make a hashmap add with key as element and index as value 
		Then simply check through containskey (function) if 2*element exists and the                                                
                        index is not equal to i
             Hashset â€“ make an hashset so here the thing to remember is first we check and if it   
                            doesn't exists then we add, so the flow is like 
First make a hashset
Check if the nums*2 exists and have another || condition (nums%2 =0 && set.contains(nums/2) return true
Else add the nums to set

Question 10. Valid Mountain Array â€” 941 (Single pass validation) 
 So the way to think here is think about peak, there will a increasing side and an decreasing side, have two pointers and increase one if the elements are increasing and decrease one (from the end) if its decreasing from the other, if they meet at the same its a peak.
Things to consider edge cases - peak is not on one of the ends for example the first element or the last 
Question 11. Replace Elements with Greatest Element on Right Side â€” 1299 (Right-to-left)
	Brute force- for left to right, check the greatest for each element and then update each        
                                element 
Optimal - Go from right to left and have a variable that keeps track of the max element and the question in my mind was how are we going to tackle the update and still read problem so we simply make a variable to check 
Question 12. Move Zeroes â€” 283 (Two pointers with zeros)
Simply have two pointers one to iterate through (using the for loop) and have one pointer that just holds the position of the zeros that we need to make a switch here and then we have a temp variable to make the switch 
Question 13. Sort Array By Parity â€” 905 (Partitioning)
We have two pointers one at start and one at end then we will have 4 cases 
	Odd , even then we swap i++,jâ€“
	Even, odd then we do nothing j- -
	Odd, odd we do nothing  i++
	odd , even we do nothing j - -
Question 14. Sort Array By Parity II â€” 922 (Even/odd positioning)
           I=0 AND J =1  and we check if i is even do nothing i+=2 similarly for j check if odd and increment by 2 places and then at the end of each for loop simply swap 
So how it looks is 
One while loop
	while(i condition)
	while(j condition)
	if(i & j both in bounds)
		Swap

Question 15. Height Checker â€” 1051 (Comparison with sorted)
	So we simply make a new array and then we clone and sort array using int sorted[] = heights.clone();Arrays.sort(sorted);
After that we have a simple for loop and check if each element is equal, if not counter increment and return counter 

Question 16. Third Maximum Number â€” 414 (Set for top elements)
	Basic approach- turn array to set, set to array then sort and give the max 			      
            Use collections-                                         Set<Integer> set = new HashSet<>();
        for(int num: nums) set.add(num);
        if(set.size()<3) return Collections.max(set);
        set.remove(Collections.max(set));
        set.remove(Collections.max(set));
        return Collections.max(set);
	Use TreeSet/ordered set
	Use Three variables 


Question 17. Find All Numbers Disappeared in an Array â€” 448 (Array as hash)
Brute force - have 2 for loops, we just find if the number is present if present ok , if not and to check use this condn  if(i == nums.length){ missing.add(number);
If not present simply add in arraylist

Inplace mark negative- simple for each element mark that indexâ€™s element as negative then when that element is not negative add the element

Question 18. Single Number â€” 136 (XOR properties) 
	So XOR is like only true when both bits are different , so what we can do here take xor of all the elements, rest of the elements will automatically become 0 and we will only be left with the distinct number.
And for implementationâ€™s purpose we will start from 0 as xor of any number with zero is number itself.
4 â†’ 0100
0 â†’ 0000      
            4 XOR 0 â†’ 0100    
So if we have an array like [4,2,1,2,1]    4^2^1^2^1 â†’ 4^0^0 â†’ 4^0 â†’ 4    


Question 19. Majority Element â€” 169 (Boyer-Moore or counting)
Brute â†’ for loop ek ke andr ek , for each count kro total if occurrence > n/2 return number.
Hashmap â†’ hashmap me daldo use getorDefault, same n/2 ka khel
Sort and give middle Approach   sorry and give n/2th element
Booyre Moore Voting â†’ have a candidate(current) for each occurrence add to its count and when the count is zero , change the candidate and at the end of the array, whichever candidate is current is the majority or winning candidate.
Bit manipulation â†’ count the the number of 1s in each position for each element , and on basis of that judge what is the numbers bits , also we need to do 32 bits as integer is 32 bits long


Question 20. Contains Duplicate â€” 217 (HashSet detection)
Simply add to hashset and check if length is equal or not 
Sort and check adjacent 
Add to hashmap if value for any key greater than 1, return duplicate 
Streams, convert to streams, 
	return Arrays.stream(nums)
             .distinct()
             .count() != nums.length;

Question 21. Best Time to Buy and Sell Stock â€” 121 (Single pass min tracking)
Brute force - check profit for each element towards all the elements to the right, simple nested for loops technique
Another approach is kind of clever , so we have use elements as as iteration , then we find minvalue we encountered till now, then we have a maxprofit , a profit
We check the profit from mintillnow and calculate profit and then compare it with maxprofit
class Solution {
   public int maxProfit(int[] prices) {
     
       int mintillnow =Integer.MAX_VALUE;
       int maxprofit=0;
       for(int price :prices){
           mintillnow =Math.min(mintillnow,price);
           int profit = price- mintillnow;
           maxprofit=Math.max(profit,maxprofit);
       }
       return maxprofit;
   }
}
 

Question  22. Find Pivot Index â€” 724 (Left vs right sum)
	So what we can do is have the total and calculate right and left sum towards each element and compare the numbers right sum = total - left sum - current element 
If ls == rs return i and if they not return -1;
Question  23. Pascal's Triangle â€” 118 (Row generation)
So the left and right most elements are 1 and rest ith term are the sum of previous rows (i-1)th + (i)th term 

So the tactical thing is we create a list of integers, and then add this list for each iteration to a list of list of integers that we are gonna return 


Question  24. Pascal's Triangle II â€” 119 (Space optimized)
Same ;like previous but we need a more optimized solution these all are o(n^2)
So a better approach is using the combinations formula, where i be the row and k be the element then iCk is the kth element 
And the tactical deplyement is like 
nC(k+1) = nCk Ã— (n-k) / (k+1)    Get next value from current
nCk = nC(k-1) Ã— (n-k+1) / k		Get current from previous (used in code)
Question  25. Find All Duplicates in an Array â€” 442 (Array as hashmap)
So the problem here says that there should be linear space utilization so the problem is when we use hashmaps, hashsets, sorting those approaches cant follow the restrain , so what we can do instead is marking the index or elements as negative , so an algorithm like 
Step1)having a list named result
Step2)calculate index 
Step3)check if nums[index] is negative
	If yes then add to result\
	In not , make the element negative

Question 26. Reverse String â€” 344 (Two pointers swap)
Simply use two pointers, one at the strating end, other at the other end, and simply use a temp and swap elements
Question  27. Valid Palindrome â€” 125 (Two pointers validation)
SO tactical points here are just use while(l<r && !Character.isLetterOrDigit(s.charAt(l))) l++
And then just checking if charAt(l) is equal to charAt(r)
Question 28. Remove Duplicates from Sorted Array II â€” 80 (Count-based removal)
So basically what we trying to have 2 pointers and we have one reading index that is a for loop, then we have a write index and we compare the writeindex-2 simply if the readindex is not equal to writeindex-2 we update the write and simply ++the write index 
Question 29. Two Sum II - Input Array Is Sorted â€” 167 (Two pointers sum)
As the array is in ascending order what we can do is have two pointers one at start and the other at end and simply return the index if sum is equal to target and if this is not the case then what we can do is compare the sum and target and accordingly  move left, right index 
Question 30. Reverse Vowels of a String â€” 345 (Conditional swap) (nice question)
SO first thing first strings are immutable so convert to array use char[] arr =s.toCharArray();
Next tactical thing is we need to check if a character is vowel we simply create a string named , vowel and then use vowels.indexOf(arr[i])==-1) 
And then we simply swap and i++,j--   

Question 31. Intersection of Two Arrays â€” 349 (Set intersection)
Have two sets first set add the nums1 and then in second set only add elements that are present both in nums1 and nums2 and at the end we convert the set to an array using streams return result.stream().mapToInt(i -> i).toArray

Question 32. Container With Most Water â€” 11 (Two pointers greedy)
Question 33. 3Sum â€” 15 (Sorted two pointers)
Question 34. 3Sum Closest â€” 16 (Distance optimization)
Question35. Sort Colors â€” 75 (Dutch flag partition)
Question36. Valid Triangle Number â€” 611 (Triangle inequality)
Question 37. Boats to Save People â€” 881 (Greedy pairing)
Question 38. Bag of Tokens â€” 948 (Two pointers strategy)


	
	



