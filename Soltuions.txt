Leetcode 

So we have phases planned 
Phase 1-2: 220 problems (Array + String fundamentals)
Phase 3: 100 problems (LinkedList + Stack/Queue)
Phase 4: 100 problems (HashMap + Binary Search)
Phase 5: 100 problems (Heap + Tree basics)
Phase 6: 80 problems (BST + Graph algorithms)

PHASE 1
Phase 1: Array Patterns (1-120)
A. Array Basics - Pure Easy (1-20)
B. Two Pointers - Gradual Complexity (21-40)
C. Sliding Window - Step by Step (41-70)
D. Prefix Sum & Array Math (71-95)
E. Advanced Array Techniques (96-120)
Phase 2: String Patterns (121-220)
A. String Fundamentals (121-145)
B. Pattern Matching - Easy to Medium (146-170)
C. Advanced String Algorithms (171-195)
D. String DP & Complex Patterns (196-220)
Phase 3: LinkedList Patterns (221-320)
A. LinkedList Fundamentals (221-245)
B. Advanced LinkedList Operations (246-270)
C. Stack Fundamentals (271-295)
D. Queue & Deque Patterns (296-320)
Phase 4: HashMap & Binary Search (321-420)
A. HashMap Fundamentals (321-350)
B. Advanced HashMap Patterns (351-375)
C. Binary Search Fundamentals (376-400)
D. Advanced Binary Search (401-420)
Phase 5: Heap & Tree Fundamentals (421-520)
A. Heap Operations (421-450)
B. Tree Traversals (451-475)
C. Tree Properties & Validation (476-500)
D. Path & Sum Problems (501-520)
Phase 6: BST & Graph Algorithms (521-600)
A. Binary Search Tree Operations (521-545)
B. Graph Traversal & Basic Algorithms (546-570)
C. Advanced Graph Algorithms (571-590)
D. Final Integration & Complex Problems (591-600)















A. Array Basics - Pure Easy (1-20)
1. Running Sum of 1d Array â€” 1480 (Basic iteration)
2. Find Numbers with Even Number of Digits â€” 1295 (Digit counting)
3. Max Consecutive Ones â€” 485 (Simple counting)
4. Squares of a Sorted Array â€” 977 (Two pointers intro)
5. Duplicate Zeros â€” 1089 (Array modification)
6. Merge Sorted Array â€” 88 (Two array merging)
7. Remove Element â€” 27 (In-place removal)
8. Remove Duplicates from Sorted Array â€” 26 (Two pointers)
9. Check If N and Its Double Exist â€” 1346 (HashSet usage)
10. Valid Mountain Array â€” 941 (Single pass validation) 
11. Replace Elements with Greatest Element on Right Side â€” 1299 (Right-to-left)
12. Move Zeroes â€” 283 (Two pointers with zeros)
13. Sort Array By Parity â€” 905 (Partitioning)
14. Sort Array By Parity II â€” 922 (Even/odd positioning)
15. Height Checker â€” 1051 (Comparison with sorted)
16. Third Maximum Number â€” 414 (Set for top elements)
17. Find All Numbers Disappeared in an Array â€” 448 (Array as hash)
18. Single Number â€” 136 (XOR properties) 
19. Majority Element â€” 169 (Boyer-Moore or counting)
20. Contains Duplicate â€” 217 (HashSet detection)


Question1. Running Sum of 1d Array â€” 1480 (Basic iteration)
Question2. Find Numbers with Even Number of Digits â€” 1295 (Digit counting)
SOLUTION) There could be many ways to do it 
1)String Conversion
String.valueOf(int i) actually calls Integer.toString(i) behind the scenes
int count=0;
       for(int i=0; i<nums.length;i++){
           if(String.valueOf(nums[i]).length()%2==0){
               count++;
2) Counting Digits
By counting digits until the quotient of that number is not equal to zero            sigle digit/10 ==0

3)Using Math (log)
Number of digits = floor(logâ‚â‚€(number)) + 1       just think int terms of log basics

int digits= (int)(Math.log10(nums[i]))+1;

4)Question specific constraints trick
5)Bit manipulation
THESE BOTH WILL BE COVERED LATER
Question3. Max Consecutive Ones â€” 485 (Simple counting)

We simply iterate and check if element is zero then the streak ends and we update streak using Math.max

Question4. Squares of a Sorted Array â€” 977 (Two pointers intro)
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
So the problem here is the negative integers everything is already sorted so the TRICK  here is after squaring we need TWO pointers 
     

[-7,-3,2,3,11]  this becomes [49, 9, 4, 9 , 121]  so between there somewhere there is a point around which everything is already sorted something like [49, 9,(that point) 4, 9 , 121]
 So we use two pointers a start and an end pointer and sort the array by shifting them 

Question5. ðŸ”¥Duplicate Zeros â€” 1089 (Array modification)

Main idea is we go from right to left, we have imaginary pointer which exceeds the array length and we just write when its within range.
Step1) Count no of zeros/extra elements
Step2) we traverse right to left and simply shift each element if j<n & if the lament is zero we shift the j pointer left once and write a zero again 

Things to remember in this code is 
First we use index to shift all elements
Second if the number is zero we shift one left and and write zero

Question6. Merge Sorted Array â€” 88 (Two array merging)
We will have three pointers one for first reading array, one for reading second , third for writing first, simply compare elements, then place, thing to remember here is the first array can be fully read before the second so then we will need to check if any left in second array and have ablock like 
while(j >= 0) {
           nums1[k] = nums2[j];
           k--;
           j--;
       }

Question7. Remove Element â€” 27 (In-place removal)
We have one pointer that reads/iterate through array and checks the what elements are not equal to value, and then we have another pointer for writing the elements.
Question8. Remove Duplicates from Sorted Array â€” 26 (Two pointers)
 Again two pointers, one pointer reads the array , here the condition is as it is ascending order you just need to check if right element is greater than the left element also what we then just switch the element with the other one 

Question9. Check If N and Its Double Exist â€” 1346 (HashSet usage)
             Brute force simple â€“ two for loops and check for each element if next exists 
             Hashmap â€“ make a hashmap add with key as element and index as value 
		Then simply check through containskey (function) if 2*element exists and the                                                
                        index is not equal to i
             Hashset â€“ make an hashset so here the thing to remember is first we check and if it   
                            doesn't exists then we add, so the flow is like 
First make a hashset
Check if the nums*2 exists and have another || condition (nums%2 =0 && set.contains(nums/2) return true
Else add the nums to set

Question 10. Valid Mountain Array â€” 941 (Single pass validation) 
 So the way to think here is think about peak, there will a increasing side and an decreasing side, have two pointers and increase one if the elements are increasing and decrease one (from the end) if its decreasing from the other, if they meet at the same its a peak.
Things to consider edge cases - peak is not on one of the ends for example the first element or the last 
Question 11. Replace Elements with Greatest Element on Right Side â€” 1299 (Right-to-left)
	Brute force- for left to right, check the greatest for each element and then update each        
                                element 
Optimal - Go from right to left and have a variable that keeps track of the max element and the question in my mind was how are we going to tackle the update and still read problem so we simply make a variable to check 
Question 12. Move Zeroes â€” 283 (Two pointers with zeros)
Simply have two pointers one to iterate through (using the for loop) and have one pointer that just holds the position of the zeros that we need to make a switch here and then we have a temp variable to make the switch 
Question 13. Sort Array By Parity â€” 905 (Partitioning)
We have two pointers one at start and one at end then we will have 4 cases 
	Odd , even then we swap i++,jâ€“
	Even, odd then we do nothing j- -
	Odd, odd we do nothing  i++
	odd , even we do nothing j - -
Question 14. Sort Array By Parity II â€” 922 (Even/odd positioning)
           I=0 AND J =1  and we check if i is even do nothing i+=2 similarly for j check if odd and increment by 2 places and then at the end of each for loop simply swap 
So how it looks is 
One while loop
	while(i condition)
	while(j condition)
	if(i & j both in bounds)
		Swap

Question 15. Height Checker â€” 1051 (Comparison with sorted)
	So we simply make a new array and then we clone and sort array using int sorted[] = heights.clone();Arrays.sort(sorted);
After that we have a simple for loop and check if each element is equal, if not counter increment and return counter 
