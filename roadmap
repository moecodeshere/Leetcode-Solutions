 Phase 1: Array Patterns - Foundation to Advanced (1-120)
A. Array Basics - Pure Easy (1-20)   
      
1. Running Sum of 1d Array — 1480 (Basic iteration)
2. Find Numbers with Even Number of Digits — 1295 (Digit counting)
3. Max Consecutive Ones — 485 (Simple counting)
4. Squares of a Sorted Array — 977 (Two pointers intro)
5. Duplicate Zeros — 1089 (Array modification)
6. Merge Sorted Array — 88 (Two array merging)
7. Remove Element — 27 (In-place removal)
8. Remove Duplicates from Sorted Array — 26 (Two pointers)
9. Check If N and Its Double Exist — 1346 (HashSet usage)
10. Valid Mountain Array — 941 (Single pass validation) 
11. Replace Elements with Greatest Element on Right Side — 1299 (Right-to-left)
12. Move Zeroes — 283 (Two pointers with zeros)
13. Sort Array By Parity — 905 (Partitioning)
14. Sort Array By Parity II — 922 (Even/odd positioning)
15. Height Checker — 1051 (Comparison with sorted)
16. Third Maximum Number — 414 (Set for top elements)
17. Find All Numbers Disappeared in an Array — 448 (Array as hash)
18. Single Number — 136 (XOR properties) 
19. Majority Element — 169 (Boyer-Moore or counting)
20. Contains Duplicate — 217 (HashSet detection)

Arrays + Two Pointers Basics (21–38)
 21. Best Time to Buy and Sell Stock — 121 (Single pass min tracking)
 22. Find Pivot Index — 724 (Left vs right sum)
 23. Pascal's Triangle — 118 (Row generation)
 24. Pascal's Triangle II — 119 (Space optimized)
 25. Find All Duplicates in an Array — 442 (Array as hashmap)
 26. Reverse String — 344 (Two pointers swap)
 27. Valid Palindrome — 125 (Two pointers validation)
 28. Remove Duplicates from Sorted Array II — 80 (Count-based removal)
 29. Two Sum II - Input Array Is Sorted — 167 (Two pointers sum)
 30. Reverse Vowels of a String — 345 (Conditional swap)
 31. Intersection of Two Arrays — 349 (Set intersection)
 32. Container With Most Water — 11 (Two pointers greedy)
 33. 3Sum — 15 (Sorted two pointers)
 34. 3Sum Closest — 16 (Distance optimization)
 35. Sort Colors — 75 (Dutch flag partition)
 36. Valid Triangle Number — 611 (Triangle inequality)
 37. Boats to Save People — 881 (Greedy pairing)
 38. Bag of Tokens — 948 (Two pointers strategy)

Sliding Window Introduction (39–52)
 39. Maximum Average Subarray I — 643 (Fixed window sum)
 40. Minimum Difference Between Highest and Lowest of K Scores — 1984 (Sorted sliding window)
 41. Grumpy Bookstore Owner — 1052 (State-based window)
 42. Max Consecutive Ones III — 1004 (Window with K flips)
 43. Longest Substring Without Repeating Characters — 3 (Variable window)
 44. Minimum Size Subarray Sum — 209 (Shrinkable window)
 45. Longest Repeating Character Replacement — 424 (Character frequency)
 46. Fruit Into Baskets — 904 (Two distinct elements)
 47. Permutation in String — 567 (Anagram window)
 48. Find All Anagrams in a String — 438 (All anagram positions)
 49. Longest Substring with At Most Two Distinct Characters — 159 (K=2 distinct)
 50. Longest Substring with At Most K Distinct Characters — 340 (Generalized K distinct)
 51. Subarrays with K Different Integers — 992 (Exact K distinct)
 52. Longest Subarray of 1's After Deleting One Element — 1493 (One deletion allowed)

HashMap Fundamentals (53–68)
 53. Two Sum — 1 (Classic hashmap)
 54. Valid Anagram — 242 (Frequency counting)
 55. Contains Duplicate III — 220 (Value and index constraint)
 56. Intersection of Two Arrays II — 350 (Frequency map)
 57. First Unique Character in a String — 387 (Frequency + order)
 58. Ransom Note — 383 (Character availability)
 59. Isomorphic Strings — 205 (Character mapping)
 60. Word Pattern — 290 (Bijection mapping)
 61. Group Anagrams — 49 (Signature grouping)
 62. Happy Number — 202 (Cycle detection)
 63. Contains Duplicate II — 219 (Index tracking)
 64. Longest Harmonious Subsequence — 594 (Adjacent frequencies)
 65. Degree of an Array — 697 (Frequency + range)
 66. Set Mismatch — 645 (Duplicate + missing)
 67. Valid Sudoku — 36 (Multiple sets)
 68. Logger Rate Limiter — 359 (Time-based hashmap)
Prefix Sum Pattern (69–78)
 69. Range Sum Query - Immutable — 303 (Prefix sum query)
 70. Range Sum Query 2D - Immutable — 304 (2D prefix sum)
 71. Matrix Block Sum — 1314 (2D range query)
 72. Product of Array Except Self — 238 (Prefix/suffix products)
 73. Subarray Sum Equals K — 560 (Prefix sum + hashmap)
 74. Continuous Subarray Sum — 523 (Modulo prefix sum)
 75. Subarray Sums Divisible by K — 974 (Modulo handling)
 76. Contiguous Array — 525 (Transform to sum problem)
 77. Maximum Size Subarray Sum Equals k — 325 (Longest subarray)
 78. Subarray Product Less Than K — 713 (Product constraint)

String Patterns (79–94)
 79. Reverse Words in a String III — 557 (Word reversal)
 80. Longest Common Prefix — 14 (Vertical scanning)
 81. Valid Palindrome II — 680 (One deletion allowed)
 82. Longest Palindrome — 409 (Character frequency)
 83. Repeated Substring Pattern — 459 (Pattern detection)
 84. Implement strStr() — 28 (Substring search)
 85. Longest Palindromic Substring — 5 (Expand around centers)
 86. Palindromic Substrings — 647 (Count palindromes)
 87. Find and Replace Pattern — 890 (Pattern matching)
 88. Group Shifted Strings — 249 (Normalization)
 89. Decode String — 394 (Stack-based parsing)
 90. String Compression — 443 (Run-length encoding)
 91. Compare Version Numbers — 165 (String parsing)
 92. Multiply Strings — 43 (String arithmetic)
 93. Add Binary — 67 (Binary addition)
 94. Repeated DNA Sequences — 187 (Rolling hash)
Bit Manipulation Introduction (95–105)
 95. Missing Number — 268 (XOR or math)
 96. Power of Two — 231 (Bit check)
 97. Number of 1 Bits — 191 (Bit counting)
 98. Reverse Bits — 190 (Bit reversal)
 99. Power of Four — 342 (Bit pattern)
 100. Single Number II — 137 (Bit counting)
 101. Single Number III — 260 (XOR grouping)
 102. Counting Bits — 338 (DP with bits)
 103. Hamming Distance — 461 (Bit difference)
 104. Find the Duplicate Number — 287 (Floyd's + bit alternative)
 105. Sum of Two Integers — 371 (Bitwise addition)

More Arrays + Greedy Introduction (106–120)
 106. Rotate Array — 189 (Cyclic rotation)
 107. Next Permutation — 31 (In-place permutation)
 108. Merge Intervals — 56 (Interval merging)
 109. Insert Interval — 57 (Interval insertion)
 110. Non-overlapping Intervals — 435 (Interval removal)
 111. Jump Game — 55 (Greedy reachability)
 112. Jump Game II — 45 (Minimum jumps)
 113. Gas Station — 134 (Greedy circuit)
 114. Candy — 135 (Two-pass greedy)
 115. Assign Cookies — 455 (Greedy assignment)
 116. Lemonade Change — 860 (Change making)
 117. Partition Labels — 763 (String partitioning)
 118. Queue Reconstruction by Height — 406 (Greedy reconstruction)
 119. Minimum Number of Arrows to Burst Balloons — 452 (Interval coverage)
 120. Meeting Rooms — 252 (Overlap check)

Phase 2: Core Structures + Patterns (121–220)
LinkedList Fundamentals (121–145)
 121. Reverse Linked List — 206 (Iterative reversal)
 122. Middle of the Linked List — 876 (Fast/slow pointers)
 123. Palindrome Linked List — 234 (Middle + reverse)
 124. Merge Two Sorted Lists — 21 (Merge operation)
 125. Remove Linked List Elements — 203 (Value removal)
 126. Delete Node in a Linked List — 237 (Node deletion)
 127. Remove Duplicates from Sorted List — 83 (Adjacent duplicates)
 128. Linked List Cycle — 141 (Floyd's detection)
 129. Linked List Cycle II — 142 (Cycle start)
 130. Intersection of Two Linked Lists — 160 (Length difference)
 131. Remove Nth Node From End of List — 19 (Two pointers)
 132. Rotate List — 61 (Circular connection)
 133. Odd Even Linked List — 328 (Position grouping)
 134. Partition List — 86 (Two-list approach)
 135. Swap Nodes in Pairs — 24 (Pair swapping)
 136. Reverse Linked List II — 92 (Sublist reversal)
 137. Reorder List — 143 (Middle + reverse + merge)
 138. Remove Duplicates from Sorted List II — 82 (All duplicates)
 139. Add Two Numbers — 2 (Elementary addition)
 140. Add Two Numbers II — 445 (Reverse order)
 141. Plus One Linked List — 369 (Increment operation)
 142. Sort List — 148 (Merge sort)
 143. Insertion Sort List — 147 (Insertion sort)
 144. Copy List with Random Pointer — 138 (Deep copy)
 145. Flatten a Multilevel Doubly Linked List — 430 (DFS flattening)

Stack Fundamentals (146–163)
 146. Valid Parentheses — 20 (Stack matching)
 147. Min Stack — 155 (Auxiliary stack)
 148. Implement Queue using Stacks — 232 (Two stacks)
 149. Backspace String Compare — 844 (Stack simulation)
 150. Remove All Adjacent Duplicates In String — 1047 (Stack removal)
 151. Remove All Adjacent Duplicates in String II — 1209 (Count-based removal)
 152. Baseball Game — 682 (Stack operations)
 153. Evaluate Reverse Polish Notation — 150 (Postfix evaluation)
 154. Basic Calculator II — 227 (Operator precedence)
 155. Decode String — 394 (Nested decoding)
 156. Next Greater Element I — 496 (Monotonic stack)
 157. Next Greater Element II — 503 (Circular array)
 158. Daily Temperatures — 739 (Temperature tracking)
 159. Online Stock Span — 901 (Running span)
 160. Sum of Subarray Minimums — 907 (Contribution method)
 161. Largest Rectangle in Histogram — 84 (Area calculation)
 162. Maximal Rectangle — 85 (2D histogram)
 163. Car Fleet — 853 (Position + speed)

Queue & Heap Basics (164–178)
 164. Design Circular Queue — 622 (Circular design)
 165. Design Circular Deque — 641 (Deque design)
 166. Moving Average from Data Stream — 346 (Window average)
 167. Number of Recent Calls — 933 (Time window)
 168. Dota2 Senate — 649 (Game simulation)
 169. Kth Largest Element in an Array — 215 (Quickselect/heap)
 170. Kth Largest Element in a Stream — 703 (Running kth)
 171. Last Stone Weight — 1046 (Heap simulation)
 172. K Closest Points to Origin — 973 (Distance heap)
 173. Top K Frequent Elements — 347 (Frequency heap)
 174. Sort Characters By Frequency — 451 (Frequency sort)
 175. Find K Pairs with Smallest Sums — 373 (Pair generation)
 176. Reorganize String — 767 (Greedy scheduling)
 177. Task Scheduler — 621 (CPU scheduling)
 178. Meeting Rooms II — 253 (Concurrent tracking)

Trees - Traversal & Basics (179–203)
 179. Binary Tree Inorder Traversal — 94 (Iterative DFS)
 180. Binary Tree Preorder Traversal — 144 (Iterative DFS)
 181. Binary Tree Postorder Traversal — 145 (Iterative DFS)
 182. Binary Tree Level Order Traversal — 102 (BFS basics)
 183. Binary Tree Level Order Traversal II — 107 (Bottom-up BFS)
 184. Binary Tree Zigzag Level Order Traversal — 103 (Alternating BFS)
 185. Binary Tree Right Side View — 199 (Level selection)
 186. Average of Levels in Binary Tree — 637 (Level computation)
 187. Find Bottom Left Tree Value — 513 (Level tracking)
 188. Maximum Depth of Binary Tree — 104 (Recursive DFS)
 189. Minimum Depth of Binary Tree — 111 (BFS or DFS)
 190. Same Tree — 100 (Structure comparison)
 191. Symmetric Tree — 101 (Mirror validation)
 192. Invert Binary Tree — 226 (Structure modification)
 193. Balanced Binary Tree — 110 (Height checking)
 194. Diameter of Binary Tree — 543 (Path through root)
 195. Sum of Left Leaves — 404 (Conditional sum)
 196. Leaf-Similar Trees — 872 (Leaf sequences)
 197. Path Sum — 112 (Root-to-leaf DFS)
 198. Path Sum II — 113 (All paths backtracking)
 199. Binary Tree Paths — 257 (Path strings)
 200. Sum Root to Leaf Numbers — 129 (Number formation)
 201. Subtree of Another Tree — 572 (Subtree matching)
 202. Merge Two Binary Trees — 617 (Tree merging)
 203. Count Good Nodes in Binary Tree — 1448 (Path tracking)

BST Operations (204–218)
 204. Search in a Binary Search Tree — 700 (BST search)
 205. Insert into a Binary Search Tree — 701 (BST insertion)
 206. Delete Node in a BST — 450 (BST deletion)
 207. Validate Binary Search Tree — 98 (BST property)
 208. Kth Smallest Element in a BST — 230 (Inorder + count)
 209. Minimum Absolute Difference in BST — 530 (Inorder difference)
 210. Find Mode in Binary Search Tree — 501 (Frequency tracking)
 211. Lowest Common Ancestor of a BST — 235 (BST LCA)
 212. Convert Sorted Array to Binary Search Tree — 108 (Balanced construction)
 213. Trim a Binary Search Tree — 669 (Range pruning)
 214. Range Sum of BST — 938 (Conditional sum)
 215. Increasing Order Search Tree — 897 (Flatten BST)
 216. Convert BST to Greater Tree — 538 (Reverse inorder)
 217. Two Sum IV - Input is a BST — 653 (BST search)
 218. Lowest Common Ancestor of a Binary Tree — 236 (General tree LCA)

Graphs - Traversal Basics (219–243)
 219. Number of Islands — 200 (Grid DFS)
 220. Max Area of Island — 695 (Area calculation)
 221. Flood Fill — 733 (Grid modification)
 222. Island Perimeter — 463 (Boundary counting)
 223. Number of Closed Islands — 1254 (Boundary check)
 224. Number of Enclaves — 1020 (Unreachable area)
 225. Surrounded Regions — 130 (Boundary DFS)
 226. Clone Graph — 133 (Graph deep copy)
 227. All Paths From Source to Target — 797 (Path enumeration)
 228. Keys and Rooms — 841 (Reachability DFS)
 229. Find if Path Exists in Graph — 1971 (Basic connectivity)
 230. Find Center of Star Graph — 1791 (Degree analysis)
 231. Find the Town Judge — 997 (In/out degree)
 232. Number of Provinces — 547 (Connected components)
 233. Number of Connected Components in an Undirected Graph — 323 (Component count)
 234. Graph Valid Tree — 261 (Tree validation)
 235. Is Graph Bipartite? — 785 (2-coloring)
 236. Possible Bipartition — 886 (Conflict graph)
 237. Pacific Atlantic Water Flow — 417 (Dual-source DFS)
 238. Shortest Bridge — 934 (Multi-source BFS)
 239. Shortest Path in Binary Matrix — 1091 (Grid BFS)
 240. As Far from Land as Possible — 1162 (Multi-source BFS)
 241. Rotting Oranges — 994 (Multi-source BFS)
 242. Walls and Gates — 286 (Multi-source BFS)
 243. Find Eventual Safe States — 802 (Cycle detection)

Phase 3: Advanced Patterns (244–295)

Binary Search Complete (244–263)
 244. Binary Search — 704 (Template)
 245. Search Insert Position — 35 (Insert location)
 246. First Bad Version — 278 (Minimize calls)
 247. Sqrt(x) — 69 (Integer square root)
 248. Valid Perfect Square — 367 (Mathematical)
 249. Guess Number Higher or Lower — 374 (Guessing game)
 250. Find First and Last Position of Element in Sorted Array — 34 (Range finding)
 251. Search in Rotated Sorted Array — 33 (Rotation handling)
 252. Find Minimum in Rotated Sorted Array — 153 (Minimum point)
 253. Find Peak Element — 162 (Local maximum)
 254. Single Element in a Sorted Array — 540 (Parity check)
 255. Find Smallest Letter Greater Than Target — 744 (Circular search)
 256. Koko Eating Bananas — 875 (Speed optimization)
 257. Capacity To Ship Packages Within D Days — 1011 (Capacity optimization)
 258. Minimum Number of Days to Make m Bouquets — 1482 (Time optimization)
 259. Split Array Largest Sum — 410 (Min-max optimization)
 260. Search a 2D Matrix — 74 (2D as 1D)
 261. Search a 2D Matrix II — 240 (Staircase search)
 262. Kth Smallest Element in a Sorted Matrix — 378 (Matrix search)
 263. Find K Closest Elements — 658 (Binary search + expand)

Union-Find Pattern (264–271)
 264. Redundant Connection — 684 (Cycle detection)
 265. Friend Circles — 547 (Component count using union-find)
 266. Regions Cut By Slashes — 959 (Grid union-find)
 267. Accounts Merge — 721 (String union-find)
 268. Most Stones Removed with Same Row or Column — 947 (Union optimization)
 269. Satisfiability of Equality Equations — 990 (Variable union)
 270. Smallest String With Swaps — 1202 (Group swaps)
 271. Number of Operations to Make Network Connected — 1319 (Component merging)

Topological Sort (272–279)
 272. Course Schedule — 207 (Cycle detection)
 273. Course Schedule II — 210 (Topological order)
 274. Minimum Height Trees — 310 (Center finding)
 275. Parallel Courses — 1136 (Level-based scheduling)
 276. Alien Dictionary — 269 (Lexicographic order)
 277. Sequence Reconstruction — 444 (Unique topology)
 278. Course Schedule IV — 1462 (Reachability query)
 279. Find All Possible Recipes from Given Supplies — 2115 (Dependency resolution)

Backtracking Complete (280–295)
 280. Subsets — 78 (Power set)
 281. Subsets II — 90 (With duplicates)
 282. Permutations — 46 (All permutations)
 283. Permutations II — 47 (With duplicates)
 284. Combinations — 77 (K-combinations)
 285. Combination Sum — 39 (Unlimited use)
 286. Combination Sum II — 40 (Each once)
 287. Combination Sum III — 216 (Fixed K numbers)
 288. Generate Parentheses — 22 (Valid sequences)
 289. Letter Combinations of a Phone Number — 17 (Digit mapping)
 290. Palindrome Partitioning — 131 (All partitions)
 291. Word Search — 79 (Grid backtracking)
 292. N-Queens — 51 (Constraint placement)
 293. Letter Case Permutation — 784 (Case combinations)
 294. Restore IP Addresses — 93 (Valid segmentation)
 295. Beautiful Arrangement — 526 (Position constraints)


Phase 4: Advanced Topics (296–355)

Advanced Graph Algorithms (296–305)
 296. Network Delay Time — 743 (Dijkstra basic)
 297. Cheapest Flights Within K Stops — 787 (Bellman-Ford)
 298. Path with Maximum Probability — 1514 (Modified Dijkstra)
 299. Path With Minimum Effort — 1631 (Grid Dijkstra)
 300. Swim in Rising Water — 778 (Binary search + BFS)
 301. Word Ladder — 127 (BFS state space)
 302. Open the Lock — 752 (BFS transformation)
 303. Minimum Cost to Connect All Points — 1584 (MST Prim's)
 304. Min Cost to Connect All Points — 1135 (MST Kruskal's)
 305. Reconstruct Itinerary — 332 (Eulerian path)

Bit Manipulation Advanced (306–310)
 306. Bitwise AND of Numbers Range — 201 (Range AND)
 307. Total Hamming Distance — 477 (All pairs distance)
 308. Maximum XOR of Two Numbers in an Array — 421 (Trie for bits)
 309. Maximum Product of Word Lengths — 318 (Bitmask optimization)
 310. UTF-8 Validation — 393 (Bit pattern matching)

Trie Complete (311–318)
 311. Implement Trie (Prefix Tree) — 208 (Trie construction)
 312. Design Add and Search Words Data Structure — 211 (Trie with wildcards)
 313. Word Search II — 212 (Trie + backtracking)
 314. Replace Words — 648 (Prefix replacement)
 315. Longest Word in Dictionary — 720 (Prefix building)
 316. Prefix and Suffix Search — 745 (Combined search)
 317. Short Encoding of Words — 820 (Suffix optimization)
 318. Map Sum Pairs — 677 (Trie with values)

Dynamic Programming (319–342)
 319. Climbing Stairs — 70 (Basic DP)
 320. House Robber — 198 (Non-adjacent selection)
 321. House Robber II — 213 (Circular array)
 322. Min Cost Climbing Stairs — 746 (Cost optimization)
 323. Maximum Product Subarray — 152 (Min/max tracking)
 324. Coin Change — 322 (Unbounded knapsack)
 325. Coin Change 2 — 518 (Count combinations)
 326. Perfect Squares — 279 (Mathematical DP)
 327. Unique Paths — 62 (Grid DP)
 328. Unique Paths II — 63 (With obstacles)
 329. Minimum Path Sum — 64 (Grid cost)
 330. Triangle — 120 (Top-down DP)
 331. Maximal Square — 221 (2D optimization)
 332. Minimum Falling Path Sum — 931 (Path selection)
 333. Dungeon Game — 174 (Reverse DP)
 334. Best Time to Buy and Sell Stock with Cooldown — 309 (State machine DP)
 335. Longest Common Subsequence — 1143 (Classic LCS)
 336. Edit Distance — 72 (String transformation)
 337. Distinct Subsequences — 115 (Count subsequences)
 338. Longest Palindromic Subsequence — 516 (Interval DP)
 339. Palindrome Partitioning II — 132 (Partition DP)
 340. Longest Increasing Subsequence — 300 (LIS with binary search)
 341. Russian Doll Envelopes — 354 (2D LIS)
 342. Delete Operation for Two Strings — 583 (LCS application)

Design Problems (343–348)
 343. LRU Cache — 146 (HashMap + doubly linked list)
 344. LFU Cache — 460 (Frequency tracking)
 345. Insert Delete GetRandom O(1) — 380 (Array + hashmap)
 346. Design Twitter — 355 (Multiple structures)
 347. Time Based Key-Value Store — 981 (Versioned storage)
 348. Design Underground System — 1396 (Nested hashmap)

Final Integration & Important Hard Problems (349–355)
 349. Trapping Rain Water — 42 (Two pointers/monotonic stack)
 350. Minimum Window Substring — 76 (Sliding window template)
 351. Binary Tree Maximum Path Sum — 124 (Tree DP)
 352. Word Ladder II — 126 (BFS + backtracking)
 353. Sudoku Solver — 37 (Backtracking constraints)
 354. Serialize and Deserialize Binary Tree — 297 (Tree encoding)
 355. Median of Two Sorted Arrays — 4 (Binary search partition)
