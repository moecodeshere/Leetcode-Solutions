

Part 1 — Arrays & Strings (1–100)
A. Fundamentals (Warm-up: counting, traversal, simple hashing)

1 Two Sum — 1 (Array, HashMap)
2 Contains Duplicate — 217 (Array, HashSet)
3 Valid Anagram — 242 (String, HashMap)
4 Plus One — 66 (Array Math)
5 Merge Sorted Array — 88 (Two Pointers, Merge)
6 Move Zeroes — 283 (Two Pointers)
7 Best Time to Buy and Sell Stock — 121 (Array, One Pass)
8 Majority Element — 169 (Boyer–Moore Voting)
9 Missing Number — 268 (Math, XOR)
10 Pascal’s Triangle — 118 (Array Construction)
11 Longest Common Prefix — 14 (String)
12 Reverse Words in a String — 151 (String)
13 Reverse Words in a String III — 557 (String)

B. Matrix Basics (straightforward simulations)

14 Transpose Matrix — 867 (Matrix)
15 Spiral Matrix — 54 (Matrix Traversal)
16 Spiral Matrix II — 59 (Matrix Construction)
17 Rotate Image — 48 (Matrix, In-place)

C. Two Pointers (start easy → classic mediums)

18 Valid Palindrome — 125 (Two Pointers)
19 Reverse String — 344 (Two Pointers)
20 Remove Duplicates from Sorted Array — 26 (Two Pointers)
21 Remove Element — 27 (Two Pointers)
22 Implement strStr() — 28 (String Matching)
23 Squares of a Sorted Array — 977 (Two Pointers)
24 3Sum — 15 (Two Pointers, Sorting)
25 3Sum Closest — 16 (Two Pointers)
26 4Sum — 18 (Two Pointers, Sorting)
27 Container With Most Water — 11 (Two Pointers)
28 Trapping Rain Water — 42 (Two Pointers, Prefix/Suffix)

D. Sliding Window (frequency maps → variable windows → deque)

29 Maximum Average Subarray I — 643 (Sliding Window)
30 Longest Substring Without Repeating Characters — 3 (Sliding Window, HashSet)
31 Minimum Size Subarray Sum — 209 (Sliding Window)
32 Permutation in String — 567 (Sliding Window, HashMap)
33 Find All Anagrams in a String — 438 (Sliding Window, HashMap)
34 Longest Repeating Character Replacement — 424 (Sliding Window)
35 Count Number of Nice Subarrays — 1248 (Sliding Window, Prefix)
36 Subarrays with K Different Integers — 992 (Sliding Window, HashMap)
37 Sliding Window Maximum — 239 (Monotonic Deque)
38 Longest Subarray of 1’s After Deleting One — 1493 (Sliding Window)

E. Prefix Sum & Kadane (fundamentals → tricky modulo)

39 Maximum Subarray — 53 (Kadane)
40 Subarray Product Less Than K — 713 (Sliding Window)
41 Find Pivot Index — 724 (Prefix Sum)
42 Range Sum Query – Immutable — 303 (Prefix Sum)
43 Range Sum Query 2D – Immutable — 304 (2D Prefix)
44 Subarray Sum Equals K — 560 (Prefix Sum, HashMap)
45 Continuous Subarray Sum — 523 (Prefix Sum, Mod)
46 Maximum Product Subarray — 152 (Kadane Variant)
47 Maximum Length of Repeated Subarray — 718 (DP / Binary Search & Hash rolling optional)
48 Minimum Value to Get Positive Step by Step Sum — 1413 (Prefix Sum)

F. Binary Search on Arrays (basic → rotated → answer-space)

49 Binary Search — 704 (Binary Search)
50 Search Insert Position — 35 (Binary Search)
51 Find First and Last Position of Element — 34 (Binary Search)
52 Search in Rotated Sorted Array — 33 (Binary Search)
53 Find Minimum in Rotated Sorted Array — 153 (Binary Search)
54 Find Minimum in Rotated Sorted Array II — 154 (Binary Search)
55 Find Peak Element — 162 (Binary Search)
56 Median of Two Sorted Arrays — 4 (Binary Search on Answer)
57 Split Array Largest Sum — 410 (Binary Search on Answer)
58 Koko Eating Bananas — 875 (Binary Search on Answer)

G. Greedy & Cyclic Sort & Extras (confidence builders)

59 Product of Array Except Self — 238 (Prefix Product)
60 Next Permutation — 31 (Greedy, Array)
61 Largest Number — 179 (Greedy, Sorting)
62 Rotate Function — 396 (Math, Array)
63 Increasing Triplet Subsequence — 334 (Greedy)
64 Longest Mountain in Array — 845 (Two Pointers)
65 Find All Duplicates in an Array — 442 (Cyclic Sort)
66 Find All Numbers Disappeared in an Array — 448 (Cyclic Sort)
67 Find the Duplicate Number — 287 (Floyd’s Cycle)
68 First Missing Positive — 41 (Cyclic Sort)
69 Max Consecutive Ones — 485 (Array)
70 Max Consecutive Ones II — 487 (Sliding Window)
71 Max Consecutive Ones III — 1004 (Sliding Window)
72 Maximum Sum Circular Subarray — 918 (Kadane Variant)

H. Classic Interview Mix (wrap-up set for A&S)

73 Jump Game — 55 (Greedy)
74 Jump Game II — 45 (Greedy / BFS thinking)
75 Gas Station — 134 (Greedy)
76 Candy — 135 (Greedy)
77 Number of Subarrays with Bounded Maximum — 795 (Sliding Window)
78 Count Binary Substrings — 696 (String, Counting)
79 Repeated Substring Pattern — 459 (String, KMP)
80 Add Binary — 67 (String Math)
81 Length of Last Word — 58 (String)
82 Valid Palindrome II — 680 (Two Pointers)
83 Valid Palindrome III — 1216 (DP)
84 Increasing Subsequences — 491 (Backtracking)
85 Minimum Window Substring — 76 (Sliding Window)
86 Palindromic Substrings — 647 (Expand / DP)
87 Longest Palindromic Substring — 5 (Expand / DP)
88 Palindrome Partitioning — 131 (Backtracking)
89 Palindrome Partitioning II — 132 (DP)
90 Word Break — 139 (DP, HashSet)
91 Word Break II — 140 (DP, Backtracking)
92 Restore IP Addresses — 93 (Backtracking)
93 Roman to Integer — 13 (HashMap)
94 Integer to Roman — 12 (Greedy)
95 Zigzag Conversion — 6 (String Simulation)
96 Longest Substring with At Most K Distinct Characters — 340 (Sliding Window)
97 Minimum Size Subarray in Circular Array — 1590 (Sliding Window)
98 Maximum Erasure Value — 1695 (Sliding Window, HashSet)
99 Subarray Sums Divisible by K — 974 (Prefix Sum, Mod)
100 Maximum Average Subarray I (review) — 643 (Sliding Window)

Part 2 — Linked List (101–160)
A. Absolute Basics (iteration, dummy nodes)

101 Reverse Linked List — 206 (Iterative & Recursive)
102 Merge Two Sorted Lists — 21 (Two Pointers)
103 Remove Linked List Elements — 203 (Dummy Node)
104 Delete Node in a Linked List — 237 (Pointer Manipulation)
105 Middle of the Linked List — 876 (Fast/Slow)
106 Remove Duplicates from Sorted List — 83 (Two Pointers)
107 Remove Duplicates from Sorted List II — 82 (Two Pointers, Dummy)
108 Convert Binary Number in a Linked List to Integer — 1290 (Iteration)

B. Fast/Slow Pointers (cycle, length tricks)

109 Palindrome Linked List — 234 (Fast/Slow + Reverse)
110 Linked List Cycle — 141 (Floyd)
111 Linked List Cycle II — 142 (Floyd, Entry)
112 Intersection of Two Linked Lists — 160 (Two Pointers)
113 Remove Nth Node From End of List — 19 (Two Pointers)
114 Swap Nodes in Pairs — 24 (Iterative / Recursive)
115 Rotate List — 61 (Two Pointers, Circular)
116 Odd Even Linked List — 328 (Rearrangement)
117 Partition List — 86 (Two Lists + Stitch)
118 Split Linked List in Parts — 725 (Iteration, Counting)

C. Merge / Sort / Arithmetic (building real skill)

119 Add Two Numbers — 2 (Elementary Math)
120 Add Two Numbers II — 445 (Stacks)
121 Merge k Sorted Lists — 23 (Heap / Divide & Conquer)
122 Sort List — 148 (Merge Sort on LL)
123 Insertion Sort List — 147 (LL Sorting)
124 Reorder List — 143 (Middle + Reverse + Merge)
125 Convert Sorted List to BST — 109 (Divide & Conquer)

D. Advanced Structure Manipulation

126 Copy List with Random Pointer — 138 (HashMap or O(1) trick)
127 Reverse Nodes in k-Group — 25 (Group Reversal)
128 Flatten a Multilevel Doubly Linked List — 430 (DFS on LL)
129 Design Linked List — 707 (Singly/Doubly Implementation)
130 Design Browser History — 1472 (Doubly Linked List)
131 Linked List Random Node — 382 (Reservoir Sampling)

E. Modern Interview LL (fresh mediums, still approachable)

132 Remove Zero Sum Consecutive Nodes — 1171 (Prefix Sum on LL)
133 Delete Middle Node of Linked List — 2095 (Two Pointers)
134 Maximum Twin Sum of a Linked List — 2130 (Middle + Reverse)
135 Merge Nodes in Between Zeros — 2181 (Aggregation)
136 Reverse Linked List II — 92 (Partial Reversal)

F. Light Review / Skill Lock-in (quick passes)

137 Palindrome Linked List (review) — 234 (Fast/Slow + Reverse)
138 Intersection of Two Linked Lists (review) — 160 (Two Pointers)
139 Linked List Cycle (review) — 141 (Floyd)
140 Linked List Cycle II (review) — 142 (Floyd Entry)
141 Remove Nth Node From End (review) — 19 (Two Pointers)
142 Rotate List (review) — 61 (Two Pointers)
143 Partition List (review) — 86 (Two Lists + Stitch)
144 Reorder List (review) — 143 (Reverse + Merge)
145 Sort List (review) — 148 (Merge Sort LL)
146 Merge k Sorted Lists (review) — 23 (Heap)
147 Add Two Numbers (review) — 2 (Math)
148 Add Two Numbers II (review) — 445 (Stacks)
149 Copy List with Random Pointer (review) — 138 (HashMap, O(1))
150 Reverse Nodes in k-Group (review) — 25 (Group Reversal)
151 Convert Sorted List to BST (review) — 109 (Recursion)
152 Odd Even Linked List (review) — 328 (Rearrangement)
153 Remove Duplicates I (review) — 83 (Two Pointers)
154 Remove Duplicates II (review) — 82 (Two Pointers, Dummy)
155 Split Linked List in Parts (review) — 725 (Counting)
156 Convert Binary LL to Integer (review) — 1290 (Iteration)
157 Insertion Sort List (review) — 147 (LL Sorting)
158 Design Linked List (review) — 707 (Implementation)
159 Design Browser History (review) — 1472 (Doubly)
160 Linked List Random Node (review) — 382 (Reservoir)


 Part 3: Stack & Queue (161–220)
A. Stack Basics (push/pop, simulation)

161 Valid Parentheses — 20 (Stack)
162 Min Stack — 155 (Stack, Design)
163 Implement Queue using Stacks — 232 (Stack Simulation)
164 Implement Stack using Queues — 225 (Queue Simulation)
165 Backspace String Compare — 844 (Stack, Two Pointers)
166 Remove Outermost Parentheses — 1021 (Stack, String)
167 Make The String Great — 1544 (Stack, String)

B. Monotonic Stack (next greater/smaller patterns)

168 Next Greater Element I — 496 (Monotonic Stack)
169 Next Greater Element II — 503 (Monotonic Stack, Circular)
170 Daily Temperatures — 739 (Monotonic Stack)
171 Final Prices With a Special Discount in a Shop — 1475 (Monotonic Stack)
172 Next Greater Element in Linked List — 1019 (Monotonic Stack, Linked List)
173 Online Stock Span — 901 (Monotonic Stack)
174 132 Pattern — 456 (Monotonic Stack)
175 Maximum Width Ramp — 962 (Monotonic Stack)
176 Sum of Subarray Minimums — 907 (Monotonic Stack, DP)
177 Remove K Digits — 402 (Monotonic Stack, Greedy)

C. Queue Fundamentals (simple queues & circular designs)

178 Number of Recent Calls — 933 (Queue, Sliding Window)
179 Design Circular Queue — 622 (Queue, Design)
180 Design Circular Deque — 641 (Deque, Design)
181 Time Needed to Buy Tickets — 2073 (Queue, Simulation)
182 Dota2 Senate — 649 (Queue)
183 Number of Students Unable to Eat Lunch — 1700 (Queue, Simulation)

D. BFS on Grids/States (intro → multi-source → weighted via deque)

184 Number of Islands — 200 (BFS/DFS, Grid)
185 Rotting Oranges — 994 (BFS, Grid)
186 01 Matrix — 542 (BFS, Multi-Source)
187 Shortest Path in Binary Matrix — 1091 (BFS, Grid)
188 Open the Lock — 752 (BFS, State Space)
189 Minimum Genetic Mutation — 433 (BFS, Strings)
190 Shortest Bridge — 934 (BFS/DFS, Grid)
191 As Far from Land as Possible — 1162 (BFS, Multi-Source)

E. Topological Sort / Kahn (queues for order)

192 Course Schedule — 207 (Topo Sort, BFS)
193 Course Schedule II — 210 (Topo Sort, BFS)
194 Minimum Height Trees — 310 (Topo-like Trimming)
195 Sort Items by Groups Respecting Dependencies — 1203 (Topo Sort)

F. Deque / Monotonic Queue (window optimization)

196 Sliding Window Maximum — 239 (Deque, Monotonic Queue)
197 Shortest Subarray with Sum at Least K — 862 (Deque, Prefix Monotone)
198 Max Value of Equation — 1499 (Deque, Monotonic)
199 Sum of Subarray Ranges — 2104 (Monotonic Stack/Deque)

G. Parsing / Calculators (stack for expressions)

200 Evaluate Reverse Polish Notation — 150 (Stack, Eval)
201 Basic Calculator II — 227 (Stack, Parsing)
202 Remove All Adjacent Duplicates in String — 1047 (Stack)
203 Remove All Adjacent Duplicates in String II — 1209 (Monotonic Stack)
204 Minimum Remove to Make Valid Parentheses — 1249 (Stack, String)

H. Mixed Stack/Queue Practice (confidence set)

205 Simplify Path — 71 (Stack, String)
206 Asteroid Collision — 735 (Stack, Simulation)
207 Next Greater Element III — 556 (Stack + Math)
208 Circular Sentence — 2490 (Queue/String warm-up)
209 Maximum Frequency Stack — 895 (Stack, HashMap)
210 Validate Stack Sequences — 946 (Stack Simulation)
211 Baseball Game — 682 (Stack, Simulation)
212 Minimum Add to Make Parentheses Valid — 921 (Stack)
213 Check If Word Is Valid After Substitutions — 1003 (Stack)
214 Minimum Time to Make Rope Colorful — 1578 (Greedy, Stack-ish)
215 Remove Duplicate Letters — 316 (Monotonic Stack, Greedy)
216 Maximum Nesting Depth of the Parentheses — 1614 (Stack, Count)
217 Next Greater Element IV (skip hard) → use review set instead: Next Greater (496/503/556)
218 Reveal Cards In Increasing Order — 950 (Queue Simulation)
219 Design Front Middle Back Queue — 1670 (Deque, Design)
220 Number of Students Doing Homework at a Given Time — 1450 (Queue thinking)

Part 4: HashMap & HashSet (221–285)
A. Counting & Basic Maps (string/array frequency)

221 First Unique Character in a String — 387 (HashMap)
222 Ransom Note — 383 (HashMap)
223 Isomorphic Strings — 205 (HashMap)
224 Word Pattern — 290 (HashMap)
225 Find the Difference — 389 (Counting / HashMap)
226 Valid Anagram — 242 (HashMap, Sorting)
227 Longest Palindrome — 409 (HashMap)
228 Unique Email Addresses — 929 (HashSet, Normalize)
229 Jewels and Stones — 771 (HashSet, Counting)

B. Grouping & Signature Hashing (canonical forms)

230 Group Anagrams — 49 (HashMap, Sorting)
231 Group Shifted Strings — 249 (HashMap, String Signature)
232 Group Special-Equivalent Strings — 893 (HashMap, Signature)
233 Find Anagram Mappings — 760 (HashMap)

C. Subarray Hashing & Prefix Tricks (core interview set)

234 Subarray Sum Equals K — 560 (Prefix Sum + HashMap)
235 Continuous Subarray Sum — 523 (Prefix Sum + Mod)
236 Subarray Sums Divisible by K — 974 (Prefix + Mod)
237 Binary Subarrays With Sum — 930 (Prefix + HashMap)
238 Count Number of Nice Subarrays — 1248 (Prefix/Window)
239 Longest Substring Without Repeating Characters — 3 (Sliding Window + Map)
240 Longest Substring with At Most K Distinct Characters — 340 (Window + Map)
241 Longest Repeating Character Replacement — 424 (Window + Count)
242 Minimum Window Substring — 76 (Window + Count)
243 Find All Anagrams in a String — 438 (Window + Count)

D. Set Logic & Lookup (presence/ordering with sets)

244 Contains Duplicate — 217 (HashSet)
245 Contains Duplicate II — 219 (HashMap/Window)
246 Contains Duplicate III — 220 (TreeSet/Ordered Map)
247 Intersection of Two Arrays — 349 (HashSet)
248 Intersection of Two Arrays II — 350 (HashMap)
249 Longest Consecutive Sequence — 128 (HashSet, O(n))

E. Hashing-Based Design (maps + arrays/lists)

250 Two Sum — 1 (HashMap)
251 Randomized Set — 380 (HashMap + Array)
252 Insert Delete GetRandom O(1) — Duplicates allowed — 381 (HashMap + Array)
253 Valid Sudoku — 36 (HashSet in 3 dimensions)
254 LRU Cache — 146 (LinkedHashMap / DLL + HashMap)
255 Design Underground System — 1396 (HashMap, Design)
256 Time Based Key-Value Store — 981 (HashMap + Binary Search)
257 Logger Rate Limiter — 359 (HashMap) (Premium—optional)
258 Design Authentication Manager — 1797 (HashMap, TTL)
259 Design a Leaderboard — 1244 (HashMap, Heaps)

F. Word Problems (maps + tries crossover)

260 Word Break — 139 (DP + HashSet)
261 Word Break II — 140 (DP + Backtracking + HashSet)
262 Replace Words — 648 (Trie + HashSet)
263 Palindrome Pairs — 336 (Trie/HashMap hybrid)
264 Concatenated Words — 472 (Trie + HashSet)

G. Extra Map Patterns (finishing touches)

265 Degree of an Array — 697 (HashMap)
266 Minimum Index Sum of Two Lists — 599 (HashMap)
267 Find Duplicate File in System — 609 (HashMap, String Parse)
268 Bulls and Cows — 299 (HashMap, Counting)
269 Valid Palindrome II — 680 (Two Pointers, Map-lite)
270 Longest Harmonious Subsequence — 594 (HashMap)
271 Number of Boomerangs — 447 (HashMap, Geometry)
272 Max Points on a Line — 149 (HashMap, Geometry)
273 Substrings That Differ by One Character — 1638 (Hashing/DP)
274 Count Good Meals — 1711 (HashMap, Powers of Two)
275 Count Pairs of Interchangeable Rectangles — 2001 (HashMap, Ratios)
276 Number of Good Pairs — 1512 (Counting)
277 Determine if Two Strings Are Close — 1657 (Counting, Multiset)
278 Check If N and Its Double Exist — 1346 (HashSet)
279 K-diff Pairs in an Array — 532 (HashMap/Set)
280 Find Players With Zero or One Losses — 2225 (Maps)
281 Count Elements With Strictly Smaller and Greater — 2148 (Counting)
282 Maximum Number of Balloons — 1189 (Counting)
283 Sort Characters By Frequency — 451 (HashMap + Heap)
284 Top K Frequent Elements — 347 (HashMap + Heap)
285 Top K Frequent Words — 692 (HashMap + Heap)


Part 5: Trees (286–375)
A. Traversal Fundamentals (build muscle memory first)

286 Same Tree — 100 (DFS, Recursion)
287 Symmetric Tree — 101 (DFS/BFS)
288 Maximum Depth of Binary Tree — 104 (DFS)
289 Minimum Depth of Binary Tree — 111 (BFS/DFS)
290 Invert Binary Tree — 226 (DFS/BFS)
291 Binary Tree Preorder Traversal — 144 (Iterative/Recursive)
292 Binary Tree Inorder Traversal — 94 (Iterative/Recursive)
293 Binary Tree Postorder Traversal — 145 (Iterative/Recursive)
294 Binary Tree Level Order Traversal — 102 (BFS)
295 Binary Tree Level Order Traversal II — 107 (BFS)

B. BFS/Views & Simple Properties (read trees layer-wise)

296 Binary Tree Zigzag Level Order Traversal — 103 (BFS)
297 Binary Tree Right Side View — 199 (BFS)
298 Average of Levels in Binary Tree — 637 (BFS)
299 Find Largest Value in Each Tree Row — 515 (BFS)
300 Find Bottom Left Tree Value — 513 (BFS)
301 Check Completeness of a Binary Tree — 958 (BFS)

C. Root-to-Leaf & Path Sums (classic recursion set)

302 Path Sum — 112 (DFS)
303 Path Sum II — 113 (DFS + Backtracking)
304 Path Sum III — 437 (Prefix Sum on Tree)
305 Binary Tree Paths — 257 (DFS)
306 Sum of Left Leaves — 404 (DFS)
307 Sum Root to Leaf Numbers — 129 (DFS)
308 Pseudo-Palindromic Paths in a Binary Tree — 1457 (DFS + Bitmask)
309 Maximum Difference Between Node and Ancestor — 1026 (DFS)

D. Shape/Counts & Simple Transforms

310 Count Complete Tree Nodes — 222 (Binary Search/DFS)
311 Merge Two Binary Trees — 617 (DFS)
312 Binary Tree Tilt — 563 (DFS)
313 Balanced Binary Tree — 110 (DFS)
314 Leaf-Similar Trees — 872 (DFS)
315 Subtree of Another Tree — 572 (DFS + String Hashing optional)
316 Construct String from Binary Tree — 606 (DFS)
317 Add One Row to Tree — 623 (BFS/DFS)
318 Univalued Binary Tree — 965 (DFS)

E. Build / Construct Trees (great recursion practice)

319 Construct Binary Tree from Preorder and Inorder Traversal — 105 (Recursion)
320 Construct Binary Tree from Inorder and Postorder Traversal — 106 (Recursion)
321 Construct Binary Tree from Preorder and Postorder Traversal — 889 (Recursion)
322 Maximum Binary Tree — 654 (Divide & Conquer)
323 Maximum Binary Tree II — 998 (Divide & Conquer)
324 All Possible Full Binary Trees — 894 (DP/Recursion)

F. BST Basics (properties + traversal)

325 Validate Binary Search Tree — 98 (DFS/Inorder)
326 Range Sum of BST — 938 (DFS)
327 Minimum Distance Between BST Nodes — 783 (Inorder)
328 Increasing Order Search Tree — 897 (Inorder, Rewire)
329 Convert BST to Greater Tree — 538 (Reverse Inorder)
330 Convert BST to Greater Sum Tree — 1038 (Reverse Inorder)
331 Kth Smallest Element in a BST — 230 (Inorder + Count)
332 Two Sum IV – Input is a BST — 653 (BST + Set/Two Pointers)

G. BST Operations & Iterators (core interview ops)

333 Lowest Common Ancestor of a BST — 235 (BST property)
334 Lowest Common Ancestor of a Binary Tree — 236 (DFS)
335 Delete Node in a BST — 450 (BST ops)
336 Binary Search Tree Iterator — 173 (Stack/Inorder)
337 Increasing BST (review) — 897 (Inorder)
338 All Elements in Two Binary Search Trees — 1305 (Merging Inorders)
339 Convert Sorted Array to Binary Search Tree — 108 (Divide & Conquer)
340 Construct Binary Search Tree from Preorder Traversal — 1008 (BST Insert/Bounds)

H. More Views, Widths, and Cousins (BFS patterns)

341 Binary Tree Vertical Order Traversal — 314 (BFS + Column Index) (Premium)
342 Maximum Width of Binary Tree — 662 (BFS + Indexing)
343 Cousins in Binary Tree — 993 (BFS/DFS)
344 Binary Tree Coloring Game — 1145 (Counting Subtrees)
345 Find Distance in a Binary Tree — 1740 (Build graph + BFS)

I. Rewiring / Flatten / Rebuild (pointer work)

346 Flatten Binary Tree to Linked List — 114 (Reverse Preorder)
347 Increasing Order Search Tree (review) — 897 (Rewire)
348 Delete Nodes and Return Forest — 1110 (DFS + Set)
349 Recover a Tree From Preorder Traversal — 1028 (Stack/Recursion)
350 Binary Tree Pruning — 814 (DFS prune)

J. N-ary Trees (quick coverage)

351 N-ary Tree Preorder Traversal — 589 (DFS)
352 N-ary Tree Postorder Traversal — 590 (DFS)
353 N-ary Tree Level Order Traversal — 429 (BFS)
354 Maximum Depth of N-ary Tree — 559 (DFS)
355 Diameter of N-ary Tree — 1522 (DFS)

K. Mixed Practice / Confidence Set (all Easy/Medium)

356 Increasing BST (final quick pass) — 897 (Inorder)
357 Find Mode in Binary Search Tree — 501 (Inorder + Counting)
358 Smallest Subtree with All the Deepest Nodes — 865 (DFS depths)
359 Path In Zigzag Labeled Binary Tree — 1104 (Math/Tree)
360 Binary Tree Level Order Successor — 102 (BFS variant)
361 Lowest Common Ancestor of Deepest Leaves — 1123 (DFS)
362 Sum of Nodes with Even-Valued Grandparent — 1315 (DFS)
363 Maximum Level Sum of a Binary Tree — 1161 (BFS)
364 Deepest Leaves Sum — 1302 (BFS/DFS)
365 Step-By-Step Directions From a Binary Tree Node to Another — 2096 (LCA + Paths)
366 Amount of Time for Binary Tree to Be Infected — 2385 (Tree to Graph + BFS)
367 Create Binary Tree From Descriptions — 2196 (HashMap + Build)
368 Construct Binary Tree from Level Order Traversal (closest: CBT Inserter) — 919 (Design + Tree)
369 CBT Inserter — 919 (Queue + Tree)
370 Maximum Binary Tree (review) — 654 (Divide & Conquer)
371 Add One Row to Tree (review) — 623 (BFS/DFS)
372 Binary Tree Zigzag Level Order (review) — 103 (BFS)
373 Right Side View (review) — 199 (BFS)
374 Validate BST (review) — 98 (DFS/Inorder)
375 Kth Smallest in BST (review) — 230 (Inorder + Count)

Part 6: Graphs (376–455)
A. Graph Representation & Traversal (adjacency lists, DFS/BFS, prerequisites)

376 Clone Graph — 133 (DFS/BFS, Graph)
377 Find if Path Exists in Graph — 1971 (DFS/BFS, Connectivity)
378 All Paths From Source to Target — 797 (DFS, DAG)
379 Keys and Rooms — 841 (DFS/BFS, Reachability)
380 Find Center of Star Graph — 1791 (Degree Insight)
381 Find the Town Judge — 997 (In/Out-Degree)
382 Course Schedule IV — 1462 (Topo/Reachability in DAG)
383 Possible Bipartition — 886 (Bipartite via BFS/DFS)
384 Is Graph Bipartite? — 785 (Bipartite via BFS/DFS)
385 Find Eventual Safe States — 802 (Reverse Graph / Outdegree)
386 Evaluate Division — 399 (Graph Build + DFS/BFS)
387 Reconstruct Itinerary — 332 (Eulerian Path, Hierholzer/Stack)
388 Loud and Rich — 851 (Graph + Topo/DFS)
389 Minimum Number of Vertices to Reach All Nodes — 1557 (Indegree Set)

B. Grid Graphs (DFS/BFS on grids; flood-fill patterns)

390 Max Area of Island — 695 (DFS/BFS, Grid)
391 Island Perimeter — 463 (DFS/BFS, Grid)
392 Surrounded Regions — 130 (DFS/BFS, Border Flood)
393 Pacific Atlantic Water Flow — 417 (BFS/DFS from Borders)
394 Number of Enclaves — 1020 (DFS/BFS, Grid)
395 Flood Fill — 733 (DFS/BFS, Grid)
396 Count Sub Islands — 1905 (DFS/BFS, Grid Compare)
397 Path With Maximum Gold — 1219 (Backtracking on Grid)
398 Number of Closed Islands — 1254 (DFS/BFS, Grid)
399 Coloring A Border — 1034 (BFS/DFS, Grid)
400 Number of Distinct Islands — 694 (DFS + Shape Canonicalization)

C. Topological Sort & DAG Patterns (Kahn’s, dependency ordering)

401 Course Schedule IV — 1462 (Topo/Reachability)
402 Find All Possible Recipes from Given Supplies — 2115 (Topo on Dependency Graph)
403 Minimum Number of Vertices to Reach All Nodes — 1557 (Indegree 0 Set)
404 Sequence Reconstruction — 444 (Topo Order Uniqueness)
405 Alien Dictionary — 269 (Topo from Lexicographic Pairs)
406 Course Schedule (review via concepts only is earlier) → skip duplicate problems

D. Union–Find / Disjoint Set Union (merging, components)

407 Number of Provinces — 547 (DSU/DFS)
408 Redundant Connection — 684 (DSU, Cycle Detection)
409 Accounts Merge — 721 (DSU + Map)
410 Smallest String With Swaps — 1202 (DSU + Sort Components)
411 Satisfiability of Equality Equations — 990 (DSU on Variables)
412 Most Stones Removed with Same Row or Column — 947 (DSU on Rows/Cols)
413 Regions Cut by Slashes — 959 (DSU on Subcells)
414 Earliest Moment When Everyone Become Friends — 1101 (DSU + Timestamps)
415 Graph Valid Tree — 261 (DSU, Connectivity)
416 Number of Operations to Make Network Connected — 1319 (DSU, Extra Edges)

E. Shortest Paths, MST & Tree-on-Graph (BFS/Dijkstra/Prim/Floyd)

417 Network Delay Time — 743 (Dijkstra / Heap)
418 Cheapest Flights Within K Stops — 787 (Bellman-Ford / BFS layering)
419 Path With Minimum Effort — 1631 (Dijkstra on Grid)
420 Path With Maximum Probability — 1514 (Max-Heap Dijkstra)
421 Minimum Cost to Connect All Points — 1584 (Prim’s MST)
422 Find the City With the Smallest Number of Neighbors at a Threshold Distance — 1334 (Floyd/Dijkstra)
423 The Maze — 490 (BFS with rolling)
424 The Maze II — 505 (Dijkstra on Grid with rolling)
425 Map of Highest Peak — 1765 (Multi-Source BFS)
426 Minimum Fuel Cost to Report to the Capital — 2477 (Tree DFS on Roads)
427 Minimum Time to Collect All Apples in a Tree — 1443 (Tree DFS Accumulation)
428 Reachable Nodes With Restrictions — 2368 (Graph + BFS/DFS)
429 Minimum Knight Moves — 1197 (BFS on Infinite Grid)
430 Tree Diameter — 1245 (Two BFS/DFS on Tree)
431 Closest Node to Given Two Nodes — 2359 (Multi-source Distances)
432 The Network Becomes Idle — 2039 (BFS + Round-trip Time)
433 K-Similar Strings (skip; hard) → already excluded
434 Connecting Cities With Minimum Cost — 1135 (Kruskal MST)

F. Construction, Constraints & Misc Graph Tasks (mixed techniques)

435 Reorder Routes to Make All Paths Lead to the City Zero — 1466 (DFS/BFS + Direction Fix)
436 Restore the Array From Adjacent Pairs — 1743 (Graph Build + DFS)
437 Destination City — 1436 (In/Out-Degree Insight)
438 Find All Groups of Farmland — 1992 (Grid Components)
439 All Ancestors of a Node in a Directed Acyclic Graph — 2192 (Topo/DP)
440 Maximum Employees to Be Invited to a Meeting — 2127 (Cycle + Tail Trees)
441 Minimum Score of a Path Between Two Cities — 2492 (MST/BFS Insight)
442 Shortest Path with Alternating Colors — 1129 (BFS with Color State)
443 Minimum Jumps to Reach Home — 1654 (BFS with State)
444 Jump Game IV — 1345 (BFS on Value-Index Graph)
445 Snakes and Ladders — 909 (BFS on Board Graph)
446 Minimum Operations to Convert Number — 2059 (BFS over Integers)
447 Nearest Exit from Entrance in Maze — 1926 (BFS on Grid)
448 Count Servers That Communicate — 1267 (Graph Degree by Rows/Cols)
449 Count Subtrees With Same Label — 1519 (Tree DFS + Counts)
450 Longest Path With Different Adjacent Characters — 2246 (Tree DFS on Directed Graph)
451 Maximal Network Rank — 1615 (Graph Degree + Count)
452 Kill Process — 582 (Tree/Graph BFS/Map)
453 Find the Celebrity — 277 (Graph Query Logic)
454 Minimum Score of a Path Between Two Cities (review) — 2492 (Graph Insight)
455 Longest Cycle in a Graph — 2360 (Cycle Detection in Directed Graph)

Part 7: Dynamic Programming (456–555)
A. 1D DP Basics (stairs → robber → simple transitions)

456 Climbing Stairs — 70 (1D DP)
457 Min Cost Climbing Stairs — 746 (1D DP)
458 Fibonacci Number — 509 (1D DP)
459 House Robber — 198 (1D DP)
460 House Robber II — 213 (1D DP, Circular)
461 Delete and Earn — 740 (1D DP, Value Compression)
462 Longest Arithmetic Subsequence of Given Difference — 1218 (Hash DP)

B. Increasing/Subsequence DP (LIS family → variants)

463 Longest Increasing Subsequence — 300 (LIS, Patience/DP)
464 Number of Longest Increasing Subsequences — 673 (DP)
465 Largest Divisible Subset — 368 (DP + Sort)
466 Maximum Length of Pair Chain — 646 (Greedy/DP)
467 Best Team With No Conflicts — 1626 (Sort + DP)

C. Stock DP (classic transitions)

468 Best Time to Buy and Sell Stock with Cooldown — 309 (State DP)
469 Best Time to Buy and Sell Stock with Transaction Fee — 714 (State DP)

D. Knapsack / Subset DP (0/1, unbounded, count ways)

470 Coin Change — 322 (Unbounded Knapsack)
471 Coin Change II — 518 (Count Ways)
472 Combination Sum IV — 377 (Order Matters DP)
473 Partition Equal Subset Sum — 416 (0/1 Knapsack)
474 Target Sum — 494 (Transform to Subset Sum)
475 Last Stone Weight II — 1049 (Subset Sum)
476 Ones and Zeroes — 474 (2D Knapsack)

E. Classic 1D/Sequence DP (decoding, arithmetic, counting)

477 Decode Ways — 91 (Digit DP)
478 Integer Break — 343 (Break/Max Product DP)
479 Count Vowels Permutation — 1220 (State DP)
480 Number of Dice Rolls With Target Sum — 1155 (Count DP)
481 Arithmetic Slices — 413 (1D DP)
482 Arithmetic Subsequences — 446 (Hash DP)

F. 2D Grid DP (paths, sums, shapes)

483 Unique Paths — 62 (Grid DP)
484 Unique Paths II — 63 (Grid DP with Obstacles)
485 Minimum Path Sum — 64 (Grid DP)
486 Triangle — 120 (Bottom-Up DP)
487 Minimum Falling Path Sum — 931 (Grid DP)
488 Count Square Submatrices with All Ones — 1277 (2D DP)
489 Maximal Square — 221 (2D DP)
490 Knight Probability in Chessboard — 688 (2D DP / Transitions)
491 Largest Plus Sign — 764 (Directional DP)
492 2 Keys Keyboard — 650 (State DP)

G. String DP (edit distance, interleave, LCS/LPS, deletions)

493 Edit Distance — 72 (2D DP)
494 Interleaving String — 97 (2D DP)
495 Longest Common Subsequence — 1143 (2D DP)
496 Longest Palindromic Subsequence — 516 (2D DP)
497 Delete Operation for Two Strings — 583 (LCS-based DP)
498 Uncrossed Lines — 1035 (LCS Variant)
499 Minimum ASCII Delete Sum for Two Strings — 712 (2D DP)
500 Is Subsequence — 392 (Greedy/DP)

H. Interval / Game / Minimax DP (ranges, choices)

501 Minimum Score Triangulation of Polygon — 1039 (Interval DP)
502 Predict the Winner — 486 (Interval/Minimax DP)
503 Stone Game — 877 (Game DP)
504 Stone Game II — 1140 (Game DP)
505 Can I Win — 464 (Memoization, Bitmask)
506 Guess Number Higher or Lower II — 375 (Interval DP)
507 Soup Servings — 808 (Probability DP)

I. Partitioning / Schedules / Weighted Picks (cut & choose)

508 Partition Array for Maximum Sum — 1043 (DP on Index)
509 Minimum Cost For Tickets — 983 (Date DP)
510 Largest Sum of Averages — 813 (Partition DP)
511 Longest String Chain — 1048 (Sort + DP)
512 Maximum Score from Performing Multiplication Operations — 1770 (2D DP)

J. Extra Solid DP Practice (modern mediums, still approachable)

513 Domino and Tromino Tiling — 790 (1D/2D DP)
514 Minimum Swaps To Make Sequences Increasing — 801 (State DP)
515 Shopping Offers — 638 (DFS + Memo)
516 Count Number of Ways to Place Houses — 2320 (Combinatorics DP)
517 Minimum Path Cost in a Grid — 2304 (Grid DP + Cost)
518 Maximum Alternating Subsequence Sum — 1911 (State DP)
519 Largest Sum of Averages — 813 (Partition DP, review)
520 Maximum Score From Performing Multiplication Operations — 1770 (2D DP, review)
521 Maximum Score of Spliced Array — 2321 (Kadane/DP)
522 Longest Arithmetic Subsequence — 1027 (DP)
523 Toss Strange Coins — 1230 (Probability DP)
524 Count Sorted Vowel Strings — 1641 (DP/Combinatorics)
525 Filling Bookcase Shelves — 1105 (DP on Width)
526 Solving Questions With Brainpower — 2140 (Reverse DP)
527 Count Ways To Build Good Strings — 2466 (1D DP)
528 Number of Distinct Roll Sequences — 2318 (State DP)
529 Egg Drop With 2 Eggs and N Floors — 1884 (DP/Math)
530 Paint House — 256 (Row DP)
531 Count All Possible Routes — 1575 (Memoization)
532 The Number of Beautiful Subsets — 2597 (Backtrack + DP)
533 Integer Replacement — 397 (Memoization)
534 Sort Integers by The Power Value — 1387 (DP on Collatz)
535 Dice Roll Simulation — 1223 (Constrained DP)
536 Knight Dialer — 935 (State DP on Graph)
537 Count Number of Texts — 2266 (Digit/State DP)
538 Largest Submatrix With Rearrangements — 1727 (Row Heights + DP)
539 Check if There Is a Valid Partition For The Array — 2369 (1D DP)
540 Out of Boundary Paths — 576 (Grid + Mod DP)
541 Maximum Subarray Sum with One Deletion — 1186 (Kadane + DP)
542 Paint Fence — 276 (State DP)
543 Paths in Matrix Whose Sum Is Divisible by K — 2435 (3D DP: i,j,mod)
544 Length of Longest Fibonacci Subsequence — 873 (Hash DP)
545 Jump Game VII — 1871 (Window/DP)
546 Stone Game VII — 1690 (Interval DP)
547 Maximum Sum of Two Non-Overlapping Subarrays — 1031 (Prefix + DP)
548 Number of Ways to Reach a Position After Exactly k Steps — 2400 (Combinatorics/DP)
549 N-th Tribonacci Number — 1137 (1D DP)
550 Longest Ideal Subsequence — 2370 (Char State DP)
551 Maximum Profit in Job Scheduling — 1235 (DP + Binary Search)
552 Maximum Earnings From Taxi — 2008 (DP + Binary Search)
553 Number of Beautiful Partitions — 2478 (String DP)
554 Number of Ways to Earn Points — 2585 (Knapsack Count DP)
555 Count Ways to Group Overlapping Ranges — 2580 (Combinatorics/DP)


-----------------------------------x------------------------------------------x--------------------------------------------x------------------------------




Phase 1: Array Fundamentals - Ultra-Gradual Progression (1-60)
A. Basic Array Access & Iteration (1-15)

Running Sum of 1d Array — 1480 (Simple accumulation)
Find Numbers with Even Number of Digits — 1295 (Counting digits)
Max Consecutive Ones — 485 (Simple counting)
Find All Numbers Disappeared in an Array — 448 (Array as hash)
Two Sum — 1 (HashMap basics)
Best Time to Buy and Sell Stock — 121 (Single pass)
Contains Duplicate — 217 (HashSet basics)
Maximum Subarray — 53 (Kadane's basic)
Plus One — 66 (Carry logic)
Move Zeroes — 283 (Two pointers intro)
Remove Element — 27 (Two pointers practice)
Remove Duplicates from Sorted Array — 26 (Two pointers on sorted)
Merge Sorted Array — 88 (Merge concept)
Majority Element — 169 (Boyer-Moore or HashMap)
Single Number — 136 (XOR introduction)

B. Two Pointers - Very Gradual (16-30)

Valid Palindrome — 125 (Basic two pointers)
Reverse String — 344 (Two pointers swap)
Two Sum II - Input Array Is Sorted — 167 (Two pointers on sorted)
Reverse Vowels of a String — 345 (Two pointers with condition)
Move Zeroes — 283 (Review with two pointers perspective)
Squares of a Sorted Array — 977 (Two pointers + comparison)
Sort Colors — 75 (Dutch flag - three pointers)
Remove Duplicates from Sorted Array II — 80 (Two pointers with count)
Partition Array According to Given Pivot — 2161 (Partitioning)
3Sum — 15 (Two pointers + outer loop)
3Sum Closest — 16 (3Sum with distance tracking)
Container With Most Water — 11 (Two pointers optimization)
4Sum — 18 (Extend 3Sum pattern)
Two Sum Less Than K — 1099 (Two pointers variant)
3Sum Smaller — 259 (3Sum with counting)

C. Sliding Window - Baby Steps (31-45)

Maximum Average Subarray I — 643 (Fixed window)
Contains Duplicate II — 219 (Window with HashMap)
Max Consecutive Ones II — 487 (Window with one flip)
Longest Substring Without Repeating Characters — 3 (Variable window)
Permutation in String — 567 (Window with frequency)
Find All Anagrams in a String — 438 (Window + anagram check)
Minimum Size Subarray Sum — 209 (Window with sum target)
Longest Repeating Character Replacement — 424 (Window with replacements)
Max Consecutive Ones III — 1004 (Window with K flips)
Fruit Into Baskets — 904 (Window with 2 types)
Longest Substring with At Most Two Distinct Characters — 159 (Window constraint)
Subarray Product Less Than K — 713 (Window with product)
Binary Subarrays With Sum — 930 (Window with binary)
Count Number of Nice Subarrays — 1248 (Window + counting)
Longest Substring with At Most K Distinct Characters — 340 (Generalize previous)

D. Prefix Sum - Gentle Introduction (46-60)

Range Sum Query - Immutable — 303 (Basic prefix sum)
Find Pivot Index — 724 (Left/right sum)
Left and Right Sum Differences — 2574 (Prefix/suffix practice)
Running Sum of 1d Array — 1480 (Review as prefix sum)
Subarray Sum Equals K — 560 (Prefix sum + HashMap)
Find the Middle Index in Array — 1991 (Pivot index variant)
Maximum Size Subarray Sum Equals k — 325 (Extend previous pattern)
Minimum Operations to Reduce X to Zero — 1658 (Prefix from both ends)
Continuous Subarray Sum — 523 (Prefix sum + modulo)
Subarray Sums Divisible by K — 974 (Modulo arithmetic)
Path Sum III — 437 (Prefix sum on trees - bridge to trees)
Range Sum Query 2D - Immutable — 304 (2D prefix sum)
Binary Subarrays With Sum — 930 (Review with prefix perspective)
Contiguous Array — 525 (Transform to prefix sum)
Maximum Size Subarray Sum Equals k — 325 (Consolidate pattern)


Phase 2: String Patterns - Systematic Build-up (61-120)
A. Basic String Operations (61-75)

Valid Anagram — 242 (Character counting)
Ransom Note — 383 (Character frequency)
First Unique Character in a String — 387 (Frequency + first occurrence)
Valid Palindrome — 125 (Review with string focus)
Longest Common Prefix — 14 (String comparison)
Reverse Words in a String III — 557 (Word reversal)
Detect Capital — 520 (String validation)
To Lower Case — 709 (Character transformation)
Jewels and Stones — 771 (Character set membership)
Unique Email Addresses — 929 (String parsing)
Goat Latin — 824 (String transformation)
Most Common Word — 819 (String parsing + frequency)
Reverse Only Letters — 917 (Selective reversal)
Length of Last Word — 58 (String boundaries)
Add Binary — 67 (String arithmetic)

B. Pattern Matching & Searching (76-90)

Implement strStr() — 28 (Basic string search)
Repeated Substring Pattern — 459 (Pattern detection)
Valid Palindrome II — 680 (Palindrome with one deletion)
Longest Palindrome — 409 (Palindrome construction)
Palindromic Substrings — 647 (Count palindromes)
Longest Palindromic Substring — 5 (Find longest palindrome)
Valid Parentheses — 20 (Stack introduction via strings)
Generate Parentheses — 22 (Backtracking introduction)
Longest Valid Parentheses — 32 (DP + Stack on strings)
Remove Invalid Parentheses — 301 (BFS approach)
Minimum Remove to Make Valid Parentheses — 1249 (Greedy approach)
Score of Parentheses — 856 (Stack with calculation)
Different Ways to Add Parentheses — 241 (Divide and conquer)
Valid Parenthesis String — 678 (Greedy with wildcards)
Minimum Add to Make Parentheses Valid — 921 (Simple counting)

C. Advanced String Patterns (91-105)

Group Anagrams — 49 (Grouping + sorting)
Find All Anagrams in a String — 438 (Review with string focus)
Minimum Window Substring — 76 (Review with string focus)
Word Pattern — 290 (Bijection mapping)
Isomorphic Strings — 205 (Character mapping)
Word Break — 139 (DP introduction)
Word Break II — 140 (DP + backtracking)
Concatenated Words — 472 (Word break extension)
Replace Words — 648 (Trie introduction)
Implement Trie (Prefix Tree) — 208 (Trie implementation)
Design Add and Search Words Data Structure — 211 (Trie with wildcards)
Word Search II — 212 (Trie + backtracking)
Palindrome Pairs — 336 (Trie + palindromes)
Short Encoding of Words — 820 (Trie optimization)
Stream of Characters — 1032 (Streaming + trie)

D. String DP & Advanced (106-120)

Edit Distance — 72 (Classic string DP)
One Edit Distance — 161 (Simplified edit distance)
Delete Operation for Two Strings — 583 (DP variant)
Minimum ASCII Delete Sum for Two Strings — 712 (Weighted DP)
Longest Common Subsequence — 1143 (Classic LCS)
Shortest Common Supersequence — 1092 (LCS application)
Distinct Subsequences — 115 (Counting DP)
Interleaving String — 97 (2D DP)
Scramble String — 87 (Complex string DP)
Regular Expression Matching — 10 (Pattern matching DP)
Wildcard Matching — 44 (Simpler pattern matching)
Minimum Window Subsequence — 727 (Subsequence problems)
Shortest Palindrome — 214 (KMP + palindromes)
Count Different Palindromic Subsequences — 730 (Complex counting)
Palindrome Partitioning — 131 (Backtracking + DP)


Phase 3: LinkedList Patterns - Ultra-Gradual Progression (121-180)
A. Basic LinkedList Operations (121-135)

Convert Binary Number in a Linked List to Integer — 1290 (Simple traversal)
Middle of the Linked List — 876 (Two-pass then one-pass)
Reverse Linked List — 206 (Basic reversal - iterative)
Palindrome Linked List — 234 (Combine middle + reverse)
Remove Linked List Elements — 203 (Simple deletion)
Delete Node in a Linked List — 237 (Node deletion without head)
Remove Duplicates from Sorted List — 83 (Simple duplicate removal)
Merge Two Sorted Lists — 21 (Basic merging)
Intersection of Two Linked Lists — 160 (Two pointer technique)
Linked List Cycle — 141 (Floyd's algorithm introduction)
Linked List Cycle II — 142 (Find cycle start)
Remove Nth Node From End of List — 19 (Two pointers with gap)
Swap Nodes in Pairs — 24 (Basic node swapping)
Reverse Linked List — 206 (Review with recursive approach)
Rotate List — 61 (Combine cycle + breaking)

B. LinkedList Manipulation - Building Complexity (136-150)

Odd Even Linked List — 328 (Rearrange by position)
Partition List — 86 (Two separate lists approach)
Remove Duplicates from Sorted List II — 82 (Remove all duplicates)
Reverse Linked List II — 92 (Partial reversal)
Split Linked List in Parts — 725 (Calculate + split)
Add Two Numbers — 2 (Digit addition with carry)
Add Two Numbers II — 445 (Stack approach for reverse digits)
Plus One Linked List — 369 (Carry propagation)
Reorder List — 143 (Middle + reverse + merge)
Sort List — 148 (Merge sort on linked list)
Insertion Sort List — 147 (Insertion sort implementation)
Reverse Nodes in k-Group — 25 (Advanced group reversal)
Swapping Nodes in a Linked List — 1721 (Swap by values/positions)
Remove Zero Sum Consecutive Nodes from Linked List — 1171 (Prefix sum)
Maximum Twin Sum of a Linked List — 2130 (Array conversion + twin concept)

C. Advanced LinkedList Patterns (151-165)

Copy List with Random Pointer — 138 (Deep copy with extra pointers)
Flatten a Multilevel Doubly Linked List — 430 (DFS on linked structure)
Merge k Sorted Lists — 23 (Heap-based merging)
Convert Sorted List to Binary Search Tree — 109 (Bridge to trees)
Linked List Random Node — 382 (Reservoir sampling)
Design Linked List — 707 (Implementation from scratch)
Design Browser History — 1472 (Doubly linked list application)
LRU Cache — 146 (HashMap + doubly linked list)
LFU Cache — 460 (Complex cache with frequency)
All O'one Data Structure — 432 (Multiple data structures)
Insert into a Sorted Circular Linked List — 708 (Circular list insertion)
Next Greater Node In Linked List — 1019 (Stack + linked list)
Delete N Nodes After M Nodes of a Linked List — 1474 (Pattern deletion)
Merge In Between Linked Lists — 1669 (Complex merging)
Delete the Middle Node of a Linked List — 2095 (Two pointers for middle)

D. Stack & Queue Foundations (166-180)

Valid Parentheses — 20 (Review - basic stack)
Implement Queue using Stacks — 232 (Stack simulation)
Implement Stack using Queues — 225 (Queue simulation)
Min Stack — 155 (Review - auxiliary stack)
Baseball Game — 682 (Stack simulation)
Backspace String Compare — 844 (Stack for backspace)
Remove All Adjacent Duplicates In String — 1047 (Stack for duplicates)
Remove All Adjacent Duplicates in String II — 1209 (Stack with count)
Make The String Great — 1544 (Stack with conditions)
Evaluate Reverse Polish Notation — 150 (Stack for evaluation)
Basic Calculator — 224 (Stack + number parsing)
Basic Calculator II — 227 (Precedence handling)
Decode String — 394 (Nested stack operations)
Number of Recent Calls — 933 (Queue basics)
Design Hit Counter — 362 (Queue for time windows)


Phase 4: Stack & Monotonic Patterns - Ultra-Gradual Progression (181-240)
A. Monotonic Stack - Baby Steps (181-195)

Next Greater Element I — 496 (Basic monotonic stack)
Next Greater Element II — 503 (Circular array handling)
Daily Temperatures — 739 (Distance calculation)
Final Prices With a Special Discount in a Shop — 1475 (Next smaller element)
Next Greater Element III — 556 (Combine with number manipulation)
132 Pattern — 456 (Three-element pattern)
Online Stock Span — 901 (Running calculations)
Sum of Subarray Minimums — 907 (Area calculation concept)
Largest Rectangle in Histogram — 84 (Classic area problem)
Maximal Rectangle — 85 (Extend histogram to 2D)
Trapping Rain Water — 42 (Review with stack approach)
Remove Duplicate Letters — 316 (Lexicographically smallest)
Create Maximum Number — 321 (Monotonic stack + merging)
Maximum Width Ramp — 962 (Monotonic with indices)
Sum of Subarray Ranges — 2104 (Min and max contributions)

B. Queue & Deque Patterns (196-210)

Design Circular Queue — 622 (Circular buffer)
Design Circular Deque — 641 (Double-ended operations)
Moving Average from Data Stream — 346 (Sliding window queue)
Time Needed to Buy Tickets — 2073 (Queue simulation)
Dota2 Senate — 649 (Queue-based game simulation)
Number of Students Unable to Eat Lunch — 1700 (Queue matching)
Reveal Cards In Increasing Order — 950 (Reverse simulation)
Design Front Middle Back Queue — 1670 (Complex deque operations)
Sliding Window Maximum — 239 (Monotonic deque)
Shortest Subarray with Sum at Least K — 862 (Deque for optimization)
Constrained Subsequence Sum — 1425 (DP + monotonic deque)
Jump Game VI — 1696 (DP optimization with deque)
Max Value of Equation — 1499 (Transform + monotonic deque)
Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit — 1438 (Min/max deques)
Find the Winner of the Circular Game — 1823 (Josephus problem)

C. Advanced Stack Applications (211-225)

Simplify Path — 71 (Stack for path processing)
Decode String — 394 (Review - nested decoding)
Asteroid Collision — 735 (Collision simulation)
Validate Stack Sequences — 946 (Stack simulation validation)
Score of Parentheses — 856 (Review - stack with calculation)
Minimum Remove to Make Valid Parentheses — 1249 (Review - greedy approach)
Basic Calculator III — 772 (Recursion + stack)
Expression Add Operators — 282 (Backtracking + expression evaluation)
Different Ways to Add Parentheses — 241 (Review - divide and conquer)
Longest Valid Parentheses — 32 (Review - DP approach)
Remove Invalid Parentheses — 301 (Review - BFS approach)
Valid Parenthesis String — 678 (Review - greedy with wildcards)
Check If Word Is Valid After Substitutions — 1003 (Stack pattern matching)
Minimum Number of Swaps to Make the String Balanced — 1963 (Balance calculation)
Minimum Add to Make Parentheses Valid — 921 (Review - simple counting)

D. Design Problems - Combining Concepts (226-240)

LRU Cache — 146 (Review - HashMap + doubly linked list)
LFU Cache — 460 (Review - frequency tracking)
Insert Delete GetRandom O(1) — 380 (Review - array + hashmap)
Insert Delete GetRandom O(1) - Duplicates allowed — 381 (Handle duplicates)
Design Twitter — 355 (Multiple data structures)
Design Search Autocomplete System — 642 (Trie + heap)
Design Log Storage System — 635 (String processing + sorting)
Logger Rate Limiter — 359 (HashMap with timestamps)
Design Hit Counter — 362 (Review - sliding window)
Design Authentication Manager — 1797 (HashMap with expiration)
Design Underground System — 1396 (Review - nested HashMap)
Time Based Key-Value Store — 981 (Review - HashMap + binary search)
Design a Leaderboard — 1244 (HashMap + sorting)
Maximum Frequency Stack — 895 (Review - frequency + stack)
Design Browser History — 1472 (Review - doubly linked list)




Phase 1: Array Patterns - Foundation to Advanced (1-120)
A. Array Basics - Pure Easy (1-20)

Running Sum of 1d Array — 1480 (Basic iteration)
Find Numbers with Even Number of Digits — 1295 (Digit counting)
Max Consecutive Ones — 485 (Simple counting)
Squares of a Sorted Array — 977 (Two pointers intro)
Duplicate Zeros — 1089 (Array modification)
Merge Sorted Array — 88 (Two array merging)
Remove Element — 27 (In-place removal)
Remove Duplicates from Sorted Array — 26 (Two pointers)
Check If N and Its Double Exist — 1346 (HashSet usage)
Valid Mountain Array — 941 (Single pass validation)
Replace Elements with Greatest Element on Right Side — 1299 (Right-to-left)
Move Zeroes — 283 (Two pointers with zeros)
Sort Array By Parity — 905 (Partitioning)
Sort Array By Parity II — 922 (Even/odd positioning)
Height Checker — 1051 (Comparison with sorted)
Third Maximum Number — 414 (Set for top elements)
Find All Numbers Disappeared in an Array — 448 (Array as hash)
Single Number — 136 (XOR properties)
Majority Element — 169 (Boyer-Moore or counting)
Contains Duplicate — 217 (HashSet detection)

B. Two Pointers - Gradual Complexity (21-40)

Valid Palindrome — 125 (Basic two pointers)
Reverse String — 344 (Two pointers swap)
Reverse Vowels of a String — 345 (Conditional swap)
Two Sum II - Input Array Is Sorted — 167 (Two pointers sum)
Remove Duplicates from Sorted Array II — 80 (Count-based removal)
Intersection of Two Arrays — 349 (Set intersection)
Intersection of Two Arrays II — 350 (Frequency intersection)
Assign Cookies — 455 (Greedy two pointers)
Array Partition I — 561 (Pairing optimization)
Minimum Difference Between Highest and Lowest of K Scores — 1984 (Sorted window)
3Sum — 15 (Two pointers + outer loop)
3Sum Closest — 16 (Distance tracking)
4Sum — 18 (Nested two pointers)
Two Sum Less Than K — 1099 (Constraint satisfaction)
3Sum Smaller — 259 (Counting variants)
Valid Triangle Number — 611 (Triangle inequality)
Container With Most Water — 11 (Area maximization)
Boats to Save People — 881 (Capacity constraint)
Sum of Square Numbers — 633 (Mathematical two pointers)
Minimize Maximum Pair Sum in Array — 1877 (Optimal pairing)

C. Sliding Window - Step by Step (41-70)

Maximum Average Subarray I — 643 (Fixed window)
Contains Duplicate II — 219 (Window with constraint)
Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold — 1343 (Fixed window condition)
Minimum Difference Between Highest and Lowest of K Scores — 1984 (Sorted sliding window)
Max Consecutive Ones II — 487 (Window with one flip)
Longest Substring Without Repeating Characters — 3 (Variable window)
Max Consecutive Ones III — 1004 (Window with K flips)
Minimum Size Subarray Sum — 209 (Target sum window)
Longest Repeating Character Replacement — 424 (Character replacement)
Permutation in String — 567 (Anagram window)
Find All Anagrams in a String — 438 (All anagram positions)
Sliding Window Maximum — 239 (Monotonic deque)
Minimum Window Substring — 76 (Complex character matching)
Substring with Concatenation of All Words — 30 (Word-based window)
Longest Substring with At Most Two Distinct Characters — 159 (Character limit)
Longest Substring with At Most K Distinct Characters — 340 (Generalized limit)
Subarrays with K Different Integers — 992 (Exact K distinct)
Count Number of Nice Subarrays — 1248 (Transform to binary)
Binary Subarrays With Sum — 930 (Binary target)
Subarray Product Less Than K — 713 (Product constraint)
Fruit Into Baskets — 904 (Two-type collection)
Get Equal Substrings Within Budget — 1208 (Cost constraint)
Minimum Operations to Reduce X to Zero — 1658 (Two-ended reduction)
Shortest Subarray with Sum at Least K — 862 (Monotonic deque optimization)
Max Value of Equation — 1499 (Coordinate transformation)
Constrained Subsequence Sum — 1425 (DP with sliding window)
Longest Subarray of 1's After Deleting One Element — 1493 (One deletion allowed)
Frequency of the Most Frequent Element — 1838 (Increment operations)
Number of Substrings Containing All Three Characters — 1358 (All three present)
Grumpy Bookstore Owner — 1052 (State-based window)

D. Prefix Sum & Array Math (71-95)

Range Sum Query - Immutable — 303 (Basic prefix sum)
Find Pivot Index — 724 (Left vs right sum)
Left and Right Sum Differences — 2574 (Dual prefix)
Find the Middle Index in Array — 1991 (Pivot variant)
Subarray Sum Equals K — 560 (Prefix + HashMap)
Continuous Subarray Sum — 523 (Modulo arithmetic)
Subarray Sums Divisible by K — 974 (Modulo with negatives)
Maximum Size Subarray Sum Equals k — 325 (Longest subarray)
Minimum Operations to Reduce X to Zero — 1658 (Two-ended prefix)
Contiguous Array — 525 (Transform to sum problem)
Maximum Average Subarray I — 643 (Review with prefix)
Range Sum Query 2D - Immutable — 304 (2D prefix sum)
Matrix Block Sum — 1314 (2D range query)
Minimum Value to Get Positive Step by Step Sum — 1413 (Running minimum)
Corporate Flight Bookings — 1109 (Range updates)
Car Pooling — 1094 (Capacity tracking)
Meeting Rooms II — 253 (Interval counting)
My Calendar I — 729 (Interval checking)
Insert Interval — 57 (Interval insertion)
Merge Intervals — 56 (Interval merging)
Non-overlapping Intervals — 435 (Interval optimization)
Minimum Number of Arrows to Burst Balloons — 452 (Interval coverage)
Interval List Intersections — 986 (Two-list intersection)
Employee Free Time — 759 (Gap finding)
Remove Covered Intervals — 1288 (Coverage detection)

E. Advanced Array Techniques (96-120)

Next Permutation — 31 (In-place permutation)
Rotate Array — 189 (Cyclic rotation)
Rotate Image — 48 (Matrix rotation)
Spiral Matrix — 54 (Matrix traversal)
Spiral Matrix II — 59 (Matrix generation)
Set Matrix Zeroes — 73 (In-place marking)
Game of Life — 289 (State simulation)
Diagonal Traverse — 498 (Diagonal order)
Reshape the Matrix — 566 (Matrix reshaping)
Flipping an Image — 832 (Row-wise operations)
Transpose Matrix — 867 (Matrix transpose)
Toeplitz Matrix — 766 (Diagonal property)
Valid Tic-Tac-Toe State — 794 (Game state validation)
Product of Array Except Self — 238 (Division-free product)
Increasing Triplet Subsequence — 334 (Subsequence detection)
Wiggle Subsequence — 376 (Pattern counting)
Longest Mountain in Array — 845 (Peak detection)
Peak Index in a Mountain Array — 852 (Binary search on property)
Find Peak Element — 162 (Peak in unsorted)
Search in Rotated Sorted Array — 33 (Rotated binary search)
Find Minimum in Rotated Sorted Array — 153 (Rotation point)
Search in Rotated Sorted Array II — 81 (With duplicates)
Find Minimum in Rotated Sorted Array II — 154 (Duplicates handling)
Search a 2D Matrix — 74 (2D binary search)
Search a 2D Matrix II — 240 (Staircase search)


Phase 2: String Patterns - Complete Mastery (121-220)
A. String Fundamentals (121-145)

Reverse String — 344 (Review)
Reverse Words in a String III — 557 (Word-level reversal)
Valid Anagram — 242 (Review)
Ransom Note — 383 (Character availability)
First Unique Character in a String — 387 (First occurrence)
Valid Palindrome — 125 (Review)
Longest Common Prefix — 14 (Vertical scanning)
To Lower Case — 709 (Character conversion)
Jewels and Stones — 771 (Review)
Unique Email Addresses — 929 (Review)
Defanging an IP Address — 1108 (Review)
Split a String in Balanced Strings — 1221 (Review)
Goat Latin — 824 (String transformation)
Reverse Only Letters — 917 (Conditional reversal)
Most Common Word — 819 (Word frequency)
Length of Last Word — 58 (Boundary detection)
Add Binary — 67 (String arithmetic)
Multiply Strings — 43 (String multiplication)
Compare Version Numbers — 165 (Version comparison)
Restore IP Addresses — 93 (String partitioning)
Integer to Roman — 12 (Number conversion)
Roman to Integer — 13 (Review)
ZigZag Conversion — 6 (Pattern construction)
Count and Say — 38 (String generation)
String Compression — 443 (Run-length encoding)

B. Pattern Matching - Easy to Medium (146-170)

Implement strStr() — 28 (Substring search)
Repeated Substring Pattern — 459 (Pattern detection)
Valid Palindrome II — 680 (One deletion allowed)
Longest Palindrome — 409 (Palindrome construction)
Palindromic Substrings — 647 (Count palindromes)
Longest Palindromic Substring — 5 (Expand around centers)
Palindrome Partitioning — 131 (Backtracking partitions)
Valid Parentheses — 20 (Review)
Generate Parentheses — 22 (Backtracking generation)
Remove Invalid Parentheses — 301 (BFS removal)
Minimum Remove to Make Valid Parentheses — 1249 (Greedy removal)
Score of Parentheses — 856 (Nested scoring)
Valid Parenthesis String — 678 (Wildcard handling)
Minimum Add to Make Parentheses Valid — 921 (Count approach)
Check If Word Is Valid After Substitutions — 1003 (Stack validation)
Remove Outermost Parentheses — 1021 (Level tracking)
Make The String Great — 1544 (Adjacent removal)
Backspace String Compare — 844 (Stack simulation)
Remove All Adjacent Duplicates In String — 1047 (Stack removal)
Remove All Adjacent Duplicates in String II — 1209 (Count-based removal)
Count Binary Substrings — 696 (Group counting)
Number of Segments in a String — 434 (Segment counting)
Detect Capital — 520 (Case validation)
Student Attendance Record I — 551 (Pattern validation)
Repeated String Match — 686 (Repetition matching)

C. Advanced String Algorithms (171-195)

Group Anagrams — 49 (Signature grouping)
Find All Anagrams in a String — 438 (Review)
Minimum Window Substring — 76 (Review)
Word Pattern — 290 (Bijection mapping)
Isomorphic Strings — 205 (Character mapping)
Find and Replace Pattern — 890 (Pattern matching)
Word Break — 139 (DP word segmentation)
Word Break II — 140 (All segmentations)
Concatenated Words — 472 (Word composition)
Replace Words — 648 (Prefix replacement)
Implement Trie (Prefix Tree) — 208 (Trie construction)
Design Add and Search Words Data Structure — 211 (Trie with wildcards)
Word Search — 79 (Grid backtracking)
Word Search II — 212 (Trie + backtracking)
Palindrome Pairs — 336 (Complex palindrome detection)
Short Encoding of Words — 820 (Trie optimization)
Stream of Characters — 1032 (Streaming pattern match)
Maximum XOR of Two Numbers in an Array — 421 (Trie for bits)
Add and Search Word — 211 (Review)
Design Search Autocomplete System — 642 (Trie + frequency)
Word Squares — 425 (Trie construction)
Camelcase Matching — 1023 (Pattern matching)
Number of Matching Subsequences — 792 (Multiple pattern tracking)
Expressive Words — 809 (String stretching)
Minimum Window Subsequence — 727 (Subsequence window)

D. String DP & Complex Patterns (196-220)

Edit Distance — 72 (Classic string DP)
One Edit Distance — 161 (Single edit check)
Delete Operation for Two Strings — 583 (LCS-based deletion)
Minimum ASCII Delete Sum for Two Strings — 712 (Weighted deletion)
Longest Common Subsequence — 1143 (Classic LCS)
Shortest Common Supersequence — 1092 (LCS application)
Distinct Subsequences — 115 (Counting DP)
Interleaving String — 97 (2D DP validation)
Scramble String — 87 (Interval DP)
Regular Expression Matching — 10 (Pattern DP)
Wildcard Matching — 44 (Simpler pattern DP)
Longest Palindromic Subsequence — 516 (Interval DP)
Palindrome Partitioning II — 132 (Partition DP)
Palindrome Partitioning III — 1278 (K-partition DP)
Count Different Palindromic Subsequences — 730 (Complex counting)
Shortest Palindrome — 214 (KMP + construction)
Valid Palindrome III — 1216 (K deletions allowed)
Minimum Insertion Steps to Make a String Palindrome — 1312 (Insertion DP)
Longest Repeating Subsequence — 1062 (Modified LCS)
Number of Distinct Islands — 694 (Path signature)
Number of Distinct Islands II — 711 (Canonical forms)
Encode and Decode Strings — 271 (Serialization)
Count Unique Characters of All Substrings of a Given String — 828 (Contribution technique)
Sum of Beauty of All Substrings — 1781 (Frequency analysis)
Number of Ways to Split a String — 1573 (Combinatorial counting)

This structure maintains:

True gradual progression within each pattern group
Proper pattern grouping with related problems together
No sudden difficulty spikes - each problem builds on the previous
Pattern mastery before moving to next pattern
Comprehensive coverage without overwhelming jumps

Would you like me to continue with the remaining phases (LinkedList, HashMap, Trees, etc.) following this same principle?RetryHyes give the rest of the listEditThe Complete Ultra-Gradual DSA Learning List - Remaining Phases

Phase 3: LinkedList Patterns - Foundation to Advanced (221-320)
A. LinkedList Fundamentals (221-245)

Convert Binary Number in a Linked List to Integer — 1290 (Simple traversal)
Middle of the Linked List — 876 (Two-pass then one-pass)
Reverse Linked List — 206 (Iterative approach)
Palindrome Linked List — 234 (Middle + reverse)
Remove Linked List Elements — 203 (Value-based removal)
Delete Node in a Linked List — 237 (Node without head)
Remove Duplicates from Sorted List — 83 (Adjacent duplicates)
Merge Two Sorted Lists — 21 (Basic merging)
Intersection of Two Linked Lists — 160 (Length difference)
Linked List Cycle — 141 (Floyd's detection)
Linked List Cycle II — 142 (Cycle start)
Remove Nth Node From End of List — 19 (Two pointers)
Swap Nodes in Pairs — 24 (Pair swapping)
Reverse Linked List — 206 (Recursive approach)
Rotate List — 61 (Circular connection)
Odd Even Linked List — 328 (Position-based grouping)
Partition List — 86 (Two-list approach)
Remove Duplicates from Sorted List II — 82 (All duplicates)
Reverse Linked List II — 92 (Sublist reversal)
Split Linked List in Parts — 725 (Equal distribution)
Add Two Numbers — 2 (Elementary addition)
Add Two Numbers II — 445 (Reverse digits)
Plus One Linked List — 369 (Increment operation)
Reorder List — 143 (Middle + reverse + merge)
Sort List — 148 (Merge sort)

B. Advanced LinkedList Operations (246-270)

Insertion Sort List — 147 (Insertion sort implementation)
Reverse Nodes in k-Group — 25 (Group reversal)
Swapping Nodes in a Linked List — 1721 (Position swapping)
Remove Zero Sum Consecutive Nodes — 1171 (Prefix sum)
Maximum Twin Sum of a Linked List — 2130 (Twin concept)
Copy List with Random Pointer — 138 (Deep copy)
Flatten a Multilevel Doubly Linked List — 430 (DFS flattening)
Merge k Sorted Lists — 23 (Heap merging)
Convert Sorted List to Binary Search Tree — 109 (List to tree)
Linked List Random Node — 382 (Reservoir sampling)
Design Linked List — 707 (From scratch)
Design Browser History — 1472 (Doubly linked)
Insert into a Sorted Circular Linked List — 708 (Circular insertion)
Next Greater Node In Linked List — 1019 (Stack + list)
Delete N Nodes After M Nodes — 1474 (Pattern deletion)
Merge In Between Linked Lists — 1669 (Complex merging)
Delete the Middle Node of a Linked List — 2095 (Middle deletion)
Find Critical Points — 2058 (Local extrema)
Reverse Nodes in Even Length Groups — 2074 (Conditional reversal)
Spiral Matrix IV — 2326 (List to matrix)
Double a Number Represented as a Linked List — 2816 (Multiplication)
Merge Two Sorted Lists — 21 (Review)
Remove Duplicates from Sorted List — 83 (Review)
Linked List Cycle — 141 (Review)
Palindrome Linked List — 234 (Review)

C. Stack Fundamentals (271-295)

Valid Parentheses — 20 (Review)
Implement Queue using Stacks — 232 (Review)
Implement Stack using Queues — 225 (Review)
Min Stack — 155 (Review)
Baseball Game — 682 (Review)
Remove All Adjacent Duplicates In String — 1047 (Review)
Backspace String Compare — 844 (Review)
Next Greater Element I — 496 (Review)
Daily Temperatures — 739 (Review)
Final Prices With Special Discount — 1475 (Review)
Evaluate Reverse Polish Notation — 150 (Expression evaluation)
Basic Calculator — 224 (Simple calculator)
Basic Calculator II — 227 (With precedence)
Decode String — 394 (Nested decoding)
Remove Duplicate Letters — 316 (Monotonic stack)
Next Greater Element II — 503 (Circular array)
Next Greater Element III — 556 (Number manipulation)
132 Pattern — 456 (Three-element pattern)
Online Stock Span — 901 (Running calculations)
Sum of Subarray Minimums — 907 (Contribution method)
Largest Rectangle in Histogram — 84 (Area calculation)
Maximal Rectangle — 85 (2D histogram)
Trapping Rain Water — 42 (Water retention)
Car Fleet — 853 (Meeting time)
Asteroid Collision — 735 (Collision simulation)

D. Queue & Deque Patterns (296-320)

Design Circular Queue — 622 (Review)
Design Circular Deque — 641 (Review)
Moving Average from Data Stream — 346 (Review)
Number of Recent Calls — 933 (Review)
Time Needed to Buy Tickets — 2073 (Queue simulation)
Dota2 Senate — 649 (Game simulation)
Number of Students Unable to Eat Lunch — 1700 (Matching simulation)
Reveal Cards In Increasing Order — 950 (Reverse simulation)
Design Front Middle Back Queue — 1670 (Complex operations)
Sliding Window Maximum — 239 (Monotonic deque)
Shortest Subarray with Sum at Least K — 862 (Deque optimization)
Constrained Subsequence Sum — 1425 (DP + deque)
Jump Game VI — 1696 (DP optimization)
Max Value of Equation — 1499 (Coordinate transform)
Longest Continuous Subarray — 1438 (Min/max deques)
Find the Winner of Circular Game — 1823 (Josephus problem)
Design Hit Counter — 362 (Time window)
Logger Rate Limiter — 359 (Rate limiting)
Design Authentication Manager — 1797 (Expiration tracking)
LRU Cache — 146 (Hash + doubly linked)
LFU Cache — 460 (Frequency tracking)
Insert Delete GetRandom O(1) — 380 (Array + hash)
All O'one Data Structure — 432 (Complex tracking)
Maximum Frequency Stack — 895 (Frequency + stack)
Design Twitter — 355 (Multiple structures)


Phase 4: HashMap & Binary Search (321-420)
A. HashMap Fundamentals (321-350)

Two Sum — 1 (Review)
Valid Anagram — 242 (Review)
Group Anagrams — 49 (Review)
First Unique Character in a String — 387 (Review)
Ransom Note — 383 (Review)
Happy Number — 202 (Cycle detection)
Isomorphic Strings — 205 (Character mapping)
Word Pattern — 290 (Bijection)
Contains Duplicate — 217 (Review)
Contains Duplicate II — 219 (Index difference)
Contains Duplicate III — 220 (Value and index)
Intersection of Two Arrays — 349 (Review)
Intersection of Two Arrays II — 350 (Review)
Find the Difference — 389 (Character difference)
Jewels and Stones — 771 (Review)
Unique Email Addresses — 929 (Review)
Subdomain Visit Count — 811 (Nested counting)
Most Common Word — 819 (Review)
Uncommon Words from Two Sentences — 884 (Frequency filtering)
Groups of Special-Equivalent Strings — 893 (String signatures)
Word Subsets — 916 (Subset validation)
Number of Good Pairs — 1512 (Review)
Check If N and Its Double Exist — 1346 (Review)
Find Players With Zero or One Losses — 2225 (Tournament tracking)
Maximum Number of Balloons — 1189 (Character constraints)
Degree of an Array — 697 (Frequency + range)
Longest Harmonious Subsequence — 594 (Adjacent frequencies)
Design HashMap — 706 (Review)
Design HashSet — 705 (Review)
Minimum Index Sum of Two Lists — 599 (Common interests)

B. Advanced HashMap Patterns (351-375)

Subarray Sum Equals K — 560 (Prefix sum)
Continuous Subarray Sum — 523 (Modulo arithmetic)
Subarray Sums Divisible by K — 974 (Negative modulo)
Maximum Size Subarray Sum Equals k — 325 (Longest subarray)
Contiguous Array — 525 (Transform problem)
Longest Substring Without Repeating Characters — 3 (Review)
Longest Substring with At Most K Distinct — 340 (Review)
Subarrays with K Different Integers — 992 (Review)
Minimum Window Substring — 76 (Review)
4Sum II — 454 (Two hashmap)
Top K Frequent Elements — 347 (Frequency + heap)
Top K Frequent Words — 692 (Custom sorting)
Sort Characters By Frequency — 451 (Review)
Valid Sudoku — 36 (Multiple sets)
Group Shifted Strings — 249 (Normalization)
Bulls and Cows — 299 (Digit frequency)
Find All Duplicates in an Array — 442 (Array as hash)
Set Mismatch — 645 (Duplicate + missing)
First Missing Positive — 41 (Cyclic sort)
Couples Holding Hands — 765 (Union-find)
Random Pick with Weight — 528 (Prefix + binary search)
Random Pick Index — 398 (Reservoir sampling)
Insert Delete GetRandom O(1) — 380 (Review)
Time Based Key-Value Store — 981 (Versioned storage)
Design Underground System — 1396 (Nested hashmap)

C. Binary Search Fundamentals (376-400)

Binary Search — 704 (Review)
Search Insert Position — 35 (Review)
First Bad Version — 278 (Review)
Guess Number Higher or Lower — 374 (Review)
Valid Perfect Square — 367 (Mathematical)
Sqrt(x) — 69 (Integer square root)
Peak Index in a Mountain Array — 852 (Property-based)
Find Peak Element — 162 (Multiple peaks)
Arranging Coins — 441 (Mathematical formula)
Find Smallest Letter Greater Than Target — 744 (Circular)
Find First and Last Position — 34 (Range finding)
Search in Rotated Sorted Array — 33 (Rotation handling)
Search in Rotated Sorted Array II — 81 (With duplicates)
Find Minimum in Rotated Sorted Array — 153 (Minimum finding)
Find Minimum in Rotated Sorted Array II — 154 (Duplicates)
Search a 2D Matrix — 74 (2D as 1D)
Search a 2D Matrix II — 240 (Staircase)
Single Element in a Sorted Array — 540 (Parity-based)
Find K Closest Elements — 658 (Binary search + expand)
Closest Binary Search Tree Value — 270 (Tree traversal)
Count Complete Tree Nodes — 222 (Tree height)
Pow(x, n) — 50 (Review)
Koko Eating Bananas — 875 (Answer space)
Capacity To Ship Packages — 1011 (Constraint optimization)
Split Array Largest Sum — 410 (Min-max optimization)

D. Advanced Binary Search (401-420)

Find the Smallest Divisor — 1283 (Threshold optimization)
Magnetic Force Between Two Balls — 1552 (Distance optimization)
Minimum Number of Days to Make m Bouquets — 1482 (Time optimization)
Ugly Number III — 1201 (Mathematical)
Minimize Max Distance to Gas Station — 774 (Precision)
Minimum Limit of Balls in a Bag — 1760 (Operations)
Maximum Number of Removable Characters — 1898 (Removal)
Minimized Maximum of Products — 2064 (Distribution)
Most Beautiful Item for Each Query — 2070 (Query optimization)
Maximum Candies Allocated — 2226 (Allocation)
Median of Two Sorted Arrays — 4 (Advanced partitioning)
Find Right Interval — 436 (Interval search)
Russian Doll Envelopes — 354 (LIS with binary search)
Longest Increasing Subsequence — 300 (Binary search LIS)
K-th Smallest Prime Fraction — 786 (Fraction search)
Find K-th Smallest Pair Distance — 719 (Distance search)
Kth Smallest Number in Multiplication Table — 668 (2D search)
Kth Smallest Element in a Sorted Matrix — 378 (Matrix search)
Find the Kth Smallest Sum — 1439 (Advanced matrix)
Count Negative Numbers in Sorted Matrix — 1351 (2D binary search)


Phase 5: Heap & Tree Fundamentals (421-520)
A. Heap Operations (421-450)

Kth Largest Element in a Stream — 703 (Review)
Last Stone Weight — 1046 (Review)
Find Kth Largest Element in an Array — 215 (Quickselect vs heap)
K Closest Points to Origin — 973 (Distance heap)
Top K Frequent Elements — 347 (Review)
Top K Frequent Words — 692 (Review)
Sort Characters By Frequency — 451 (Review)
Ugly Number II — 264 (Multiple streams)
Super Ugly Number — 313 (Generalized)
Find K Pairs with Smallest Sums — 373 (Pair generation)
Reorganize String — 767 (Greedy scheduling)
Rearrange String k Distance Apart — 358 (Constraint scheduling)
Task Scheduler — 621 (CPU scheduling)
Distant Barcodes — 1054 (Arrangement)
Hand of Straights — 846 (Grouping)
Divide Array in Sets — 1296 (Consecutive sets)
Stone Game VI — 1686 (Game theory)
Furthest Building You Can Reach — 1642 (Resource allocation)
Maximum Star Sum of a Graph — 2497 (Graph + selection)
Design a Number Container System — 2349 (Multiple structures)
Smallest Number in Infinite Set — 2336 (Set operations)
Maximize Sum After K Negations — 1005 (Optimal negation)
Maximum Subsequence Score — 2542 (Selection optimization)
Total Cost to Hire K Workers — 2462 (Two-ended selection)
Minimum Deviation in Array — 1675 (Min-max optimization)
Find Median from Data Stream — 295 (Two heaps)
Sliding Window Median — 480 (Two heaps + sliding)
IPO — 502 (Dual criteria)
Course Schedule III — 630 (Deadline scheduling)
Single-Threaded CPU — 1834 (Task simulation)

B. Tree Traversals (451-475)

Binary Tree Inorder Traversal — 94 (Iterative + recursive)
Binary Tree Preorder Traversal — 144 (Both approaches)
Binary Tree Postorder Traversal — 145 (Both approaches)
Binary Tree Level Order Traversal — 102 (Review)
Binary Tree Level Order Traversal II — 107 (Bottom-up)
Binary Tree Zigzag Level Order Traversal — 103 (Alternating)
Binary Tree Right Side View — 199 (Level selection)
Find Bottom Left Tree Value — 513 (Level tracking)
Find Largest Value in Each Tree Row — 515 (Level maximum)
Average of Levels in Binary Tree — 637 (Level calculation)
N-ary Tree Preorder Traversal — 589 (Generalization)
N-ary Tree Postorder Traversal — 590 (N-ary postorder)
N-ary Tree Level Order Traversal — 429 (N-ary BFS)
Maximum Depth of N-ary Tree — 559 (N-ary depth)
Serialize and Deserialize Binary Tree — 297 (Tree persistence)
Serialize and Deserialize N-ary Tree — 428 (N-ary persistence)
Encode N-ary Tree to Binary Tree — 431 (Tree transformation)
Verify Preorder Serialization — 331 (Validation)
Find Duplicate Subtrees — 652 (Subtree hashing)
Most Frequent Subtree Sum — 508 (Subtree frequencies)
Count Univalue Subtrees — 250 (Uniform subtrees)
Binary Tree Vertical Order Traversal — 314 (Coordinate-based)
Vertical Order Traversal of a Binary Tree — 987 (Complex ordering)
Binary Tree Coloring Game — 1145 (Game on trees)
Amount of Time for Binary Tree to Be Infected — 2385 (BFS simulation)

C. Tree Properties & Validation (476-500)

Same Tree — 100 (Structure comparison)
Symmetric Tree — 101 (Mirror validation)
Invert Binary Tree — 226 (Structure modification)
Maximum Depth of Binary Tree — 104 (Review)
Minimum Depth of Binary Tree — 111 (Leaf depth)
Balanced Binary Tree — 110 (Height balance)
Diameter of Binary Tree — 543 (Path length)
Binary Tree Tilt — 563 (Sum differences)
Sum of Left Leaves — 404 (Conditional sum)
Leaf-Similar Trees — 872 (Leaf sequences)
Subtree of Another Tree — 572 (Subtree matching)
Merge Two Binary Trees — 617 (Tree merging)
Univalued Binary Tree — 965 (Single value)
Cousins in Binary Tree — 993 (Level relationships)
Check Completeness of a Binary Tree — 958 (Completeness)
Complete Binary Tree Inserter — 919 (Maintain completeness)
Maximum Width of Binary Tree — 662 (Level indexing)
Minimum Distance Between BST Nodes — 783 (Inorder differences)
Two Sum IV - Input is a BST — 653 (BST search)
Lowest Common Ancestor of a Binary Tree — 236 (LCA algorithm)
All Nodes Distance K in Binary Tree — 863 (Distance queries)
Binary Tree Cameras — 968 (Greedy optimization)
Distribute Coins in Binary Tree — 979 (Resource distribution)
Time Needed to Inform All Employees — 1376 (Tree broadcasting)
Flip Equivalent Binary Trees — 951 (Equivalent structures)

D. Path & Sum Problems (501-520)

Path Sum — 112 (Root-to-leaf)
Path Sum II — 113 (All paths)
Path Sum III — 437 (Any path)
Binary Tree Paths — 257 (Path strings)
Sum Root to Leaf Numbers — 129 (Number formation)
Binary Tree Maximum Path Sum — 124 (Maximum path)
Longest Univalue Path — 687 (Same value path)
House Robber III — 337 (Tree DP)
Maximum Difference Between Node and Ancestor — 1026 (Path tracking)
Sum of Nodes with Even-Valued Grandparent — 1315 (Multi-level)
Deepest Leaves Sum — 1302 (Level-specific)
Maximum Level Sum of a Binary Tree — 1161 (Level comparison)
Count Good Nodes in Binary Tree — 1448 (Path maximum)
Pseudo-Palindromic Paths — 1457 (Digit frequency)
Sum of Distances in Tree — 834 (All distances)
Smallest Subtree with all Deepest Nodes — 865 (LCA deepest)
Lowest Common Ancestor of Deepest Leaves — 1123 (Same as above)
Number of Good Leaf Nodes Pairs — 1530 (Leaf distances)
Delete Nodes And Return Forest — 1110 (Conditional deletion)
Step-By-Step Directions — 2096 (LCA + paths)


Phase 6: BST & Graph Algorithms (521-600)
A. Binary Search Tree Operations (521-545)

Search in a Binary Search Tree — 700 (Basic search)
Insert into a Binary Search Tree — 701 (Basic insertion)
Delete Node in a BST — 450 (Complex deletion)
Validate Binary Search Tree — 98 (Property validation)
Recover Binary Search Tree — 99 (Fix swapped)
Convert BST to Greater Tree — 538 (Reverse inorder)
Increasing Order Search Tree — 897 (Flatten BST)
Range Sum of BST — 938 (Conditional sum)
Trim a Binary Search Tree — 669 (Range pruning)
Balance a Binary Search Tree — 1382 (Rebalancing)
Kth Smallest Element in a BST — 230 (Inorder + count)
Binary Search Tree Iterator — 173 (Controlled traversal)
Lowest Common Ancestor of a BST — 235 (BST property)
All Elements in Two BSTs — 1305 (Merge inorders)
Construct BST from Preorder — 1008 (Construction)
Minimum Absolute Difference in BST — 530 (Inorder difference)
Find Mode in Binary Search Tree — 501 (Frequency tracking)
Serialize and Deserialize BST — 449 (BST serialization)
Unique Binary Search Trees — 96 (Catalan numbers)
Unique Binary Search Trees II — 95 (Generate all)
Closest Binary Search Tree Value — 270 (Distance minimization)
Closest Binary Search Tree Value II — 272 (K closest)
Inorder Successor in BST — 285 (Next element)
Inorder Successor in BST II — 510 (With parent)
Convert Sorted Array to BST — 108 (Balanced construction)

B. Graph Traversal & Basic Algorithms (546-570)

Find if Path Exists in Graph — 1971 (Basic connectivity)
Find Center of Star Graph — 1791 (Degree analysis)
Find the Town Judge — 997 (In/out degree)
Number of Islands — 200 (Review)
Max Area of Island — 695 (Area calculation)
Island Perimeter — 463 (Boundary counting)
Flood Fill — 733 (Review)
Number of Closed Islands — 1254 (Boundary handling)
Number of Enclaves — 1020 (Unreachable area)
Surrounded Regions — 130 (Boundary escape)
Pacific Atlantic Water Flow — 417 (Dual-source DFS)
Clone Graph — 133 (Deep copy)
All Paths From Source to Target — 797 (Path enumeration)
Keys and Rooms — 841 (Reachability)
Number of Provinces — 547 (Connected components)
Is Graph Bipartite? — 785 (2-coloring)
Possible Bipartition — 886 (Conflict bipartition)
Graph Valid Tree — 261 (Tree conditions)
Number of Connected Components — 323 (Component counting)
Redundant Connection — 684 (Union-find cycle)
Accounts Merge — 721 (Union-find strings)
Most Stones Removed — 947 (Union-find optimization)
Satisfiability of Equality Equations — 990 (Union-find variables)
Find Eventual Safe States — 802 (Cycle detection)
Loud and Rich — 851 (DFS memoization)

C. Advanced Graph Algorithms (571-590)

Course Schedule — 207 (Topological sort)
Course Schedule II — 210 (Topological order)
Course Schedule IV — 1462 (Reachability)
Minimum Height Trees — 310 (Tree-like topology)
Alien Dictionary — 269 (Lexicographic topology)
Sequence Reconstruction — 444 (Unique topology)
Sort Items by Groups — 1203 (Nested topology)
Parallel Courses — 1136 (Level-based)
All Ancestors in DAG — 2192 (Reverse graph)
Minimum Vertices to Reach All — 1557 (Source identification)
Network Delay Time — 743 (Dijkstra basic)
Cheapest Flights Within K Stops — 787 (Bellman-Ford)
Path with Maximum Probability — 1514 (Modified Dijkstra)
Path With Minimum Effort — 1631 (Grid Dijkstra)
The Maze — 490 (BFS with rolling)
The Maze II — 505 (Dijkstra rolling)
Shortest Path in Binary Matrix — 1091 (Grid BFS)
Shortest Bridge — 934 (Multi-source BFS)
Word Ladder — 127 (BFS state space)
Open the Lock — 752 (BFS transformation)

D. Final Integration & Complex Problems (591-600)

Word Ladder II — 126 (Path reconstruction)
Sliding Puzzle — 773 (BFS state)
Shortest Path to Get All Keys — 864 (BFS + bitmask)
Minimum Cost to Connect All Points — 1584 (MST Prim's)
Connecting Cities With Minimum Cost — 1135 (MST basic)
Swim in Rising Water — 778 (Binary search + BFS)
Trapping Rain Water II — 407 (Priority queue)
The Skyline Problem — 218 (Sweep line)
Edit Distance — 72 (String DP)
Longest Increasing Subsequence — 300 (DP optimization)

This completes the 600-problem ultra-gradual learning list with:

Proper pattern grouping within each phase
True gradual difficulty progression - no sudden spikes
Pattern mastery before advancing to next concepts
Strategic reviews to reinforce learning
Comprehensive coverage of all major DSA topics
Achievable progression where each problem builds on previous knowledge
RetryHgive me the structure of the current listEditCurrent List Structure Overview
Phase 1: Array Patterns (1-120)

A. Array Basics - Pure Easy (1-20)
B. Two Pointers - Gradual Complexity (21-40)
C. Sliding Window - Step by Step (41-70)
D. Prefix Sum & Array Math (71-95)
E. Advanced Array Techniques (96-120)

Phase 2: String Patterns (121-220)

A. String Fundamentals (121-145)
B. Pattern Matching - Easy to Medium (146-170)
C. Advanced String Algorithms (171-195)
D. String DP & Complex Patterns (196-220)

Phase 3: LinkedList Patterns (221-320)

A. LinkedList Fundamentals (221-245)
B. Advanced LinkedList Operations (246-270)
C. Stack Fundamentals (271-295)
D. Queue & Deque Patterns (296-320)

Phase 4: HashMap & Binary Search (321-420)

A. HashMap Fundamentals (321-350)
B. Advanced HashMap Patterns (351-375)
C. Binary Search Fundamentals (376-400)
D. Advanced Binary Search (401-420)

Phase 5: Heap & Tree Fundamentals (421-520)

A. Heap Operations (421-450)
B. Tree Traversals (451-475)
C. Tree Properties & Validation (476-500)
D. Path & Sum Problems (501-520)

Phase 6: BST & Graph Algorithms (521-600)

A. Binary Search Tree Operations (521-545)
B. Graph Traversal & Basic Algorithms (546-570)
C. Advanced Graph Algorithms (571-590)
D. Final Integration & Complex Problems (591-600)


Key Structural Features
Pattern-Based Organization

Problems grouped by algorithmic pattern/technique
Each subsection focuses on one specific skill
Progressive difficulty within each pattern group

Gradual Learning Progression

Each phase builds on knowledge from previous phases
Within each subsection: Easy → Easy-Medium → Medium → Medium-Hard
No sudden jumps in complexity

Problem Distribution

Phase 1-2: 220 problems (Array + String fundamentals)
Phase 3: 100 problems (LinkedList + Stack/Queue)
Phase 4: 100 problems (HashMap + Binary Search)
Phase 5: 100 problems (Heap + Tree basics)
Phase 6: 80 problems (BST + Graph algorithms)
