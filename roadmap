# Phase 1: Array Patterns - Foundation to Advanced (1-109)

## A. Array Basics - Pure Easy (1-20)
1. Running Sum of 1d Array — 1480 (Basic iteration)
2. Find Numbers with Even Number of Digits — 1295 (Digit counting)
3. Max Consecutive Ones — 485 (Simple counting)
4. Squares of a Sorted Array — 977 (Two pointers intro)
5. Duplicate Zeros — 1089 (Array modification)
6. Merge Sorted Array — 88 (Two array merging)
7. Remove Element — 27 (In-place removal)
8. Remove Duplicates from Sorted Array — 26 (Two pointers)
9. Check If N and Its Double Exist — 1346 (HashSet usage)
10. Valid Mountain Array — 941 (Single pass validation)
11. Replace Elements with Greatest Element on Right Side — 1299 (Right-to-left)
12. Move Zeroes — 283 (Two pointers with zeros)
13. Sort Array By Parity — 905 (Partitioning)
14. Sort Array By Parity II — 922 (Even/odd positioning)
15. Height Checker — 1051 (Comparison with sorted)
16. Third Maximum Number — 414 (Set for top elements)
17. Find All Numbers Disappeared in an Array — 448 (Array as hash)
18. Single Number — 136 (XOR properties)
19. Majority Element — 169 (Boyer-Moore or counting)
20. Contains Duplicate — 217 (HashSet detection)

## Arrays + Two Pointers Basics (21-38)
21. Best Time to Buy and Sell Stock — 121 (Single pass min tracking)
22. Find Pivot Index — 724 (Left vs right sum)
23. Pascal's Triangle — 118 (Row generation)
24. Pascal's Triangle II — 119 (Space optimized)
25. Find All Duplicates in an Array — 442 (Array as hashmap)
26. Reverse String — 344 (Two pointers swap)
27. Valid Palindrome — 125 (Two pointers validation)
28. Remove Duplicates from Sorted Array II — 80 (Count-based removal)
29. Two Sum II - Input Array Is Sorted — 167 (Two pointers sum)
30. Reverse Vowels of a String — 345 (Conditional swap)
31. Intersection of Two Arrays — 349 (Set intersection)
32. Container With Most Water — 11 (Two pointers greedy)
33. 3Sum — 15 (Sorted two pointers)
34. 3Sum Closest — 16 (Distance optimization)
35. Sort Colors — 75 (Dutch flag partition)
36. Valid Triangle Number — 611 (Triangle inequality)
37. Boats to Save People — 881 (Greedy pairing)
38. Bag of Tokens — 948 (Two pointers strategy)

## Sliding Window Introduction (39-52)
39. Maximum Average Subarray I — 643 (Fixed window sum)
40. Minimum Difference Between Highest and Lowest of K Scores — 1984 (Sorted sliding window)
41. Grumpy Bookstore Owner — 1052 (State-based window)
42. Max Consecutive Ones III — 1004 (Window with K flips)
43. Longest Substring Without Repeating Characters — 3 (Variable window)
44. Minimum Size Subarray Sum — 209 (Shrinkable window)
45. Longest Repeating Character Replacement — 424 (Character frequency)
46. Fruit Into Baskets — 904 (Two distinct elements)
47. Permutation in String — 567 (Anagram window)
48. Find All Anagrams in a String — 438 (All anagram positions)
49. Longest Substring with At Most Two Distinct Characters — 159 (K=2 distinct)
50. Longest Substring with At Most K Distinct Characters — 340 (Generalized K distinct)
51. Subarrays with K Different Integers — 992 (Exact K distinct)
52. Longest Subarray of 1's After Deleting One Element — 1493 (One deletion allowed)

## HashMap Fundamentals (53-68)
53. Two Sum — 1 (Classic hashmap)
54. Valid Anagram — 242 (Frequency counting)
55. Contains Duplicate III — 220 (Value and index constraint)
56. Intersection of Two Arrays II — 350 (Frequency map)
57. First Unique Character in a String — 387 (Frequency + order)
58. Ransom Note — 383 (Character availability)
59. Isomorphic Strings — 205 (Character mapping)
60. Word Pattern — 290 (Bijection mapping)
61. Group Anagrams — 49 (Signature grouping)
62. Happy Number — 202 (Cycle detection)
63. Contains Duplicate II — 219 (Index tracking)
64. Longest Harmonious Subsequence — 594 (Adjacent frequencies)
65. Degree of an Array — 697 (Frequency + range)
66. Set Mismatch — 645 (Duplicate + missing)
67. Valid Sudoku — 36 (Multiple sets)
68. Logger Rate Limiter — 359 (Time-based hashmap)

## Prefix Sum Pattern (69-78)
69. Range Sum Query - Immutable — 303 (Prefix sum query)
70. Range Sum Query 2D - Immutable — 304 (2D prefix sum)
71. Matrix Block Sum — 1314 (2D range query)
72. Product of Array Except Self — 238 (Prefix/suffix products)
73. Subarray Sum Equals K — 560 (Prefix sum + hashmap)
74. Continuous Subarray Sum — 523 (Modulo prefix sum)
75. Subarray Sums Divisible by K — 974 (Modulo handling)
76. Contiguous Array — 525 (Transform to sum problem)
77. Maximum Size Subarray Sum Equals k — 325 (Longest subarray)
78. Subarray Product Less Than K — 713 (Product constraint)

## String Patterns (79-94)
79. Reverse Words in a String III — 557 (Word reversal)
80. Longest Common Prefix — 14 (Vertical scanning)
81. Valid Palindrome II — 680 (One deletion allowed)
82. Longest Palindrome — 409 (Character frequency)
83. Repeated Substring Pattern — 459 (Pattern detection)
84. Implement strStr() — 28 (Substring search)
85. Longest Palindromic Substring — 5 (Expand around centers)
86. Palindromic Substrings — 647 (Count palindromes)
87. Find and Replace Pattern — 890 (Pattern matching)
88. Group Shifted Strings — 249 (Normalization)
89. Decode String — 394 (Stack-based parsing)
90. String Compression — 443 (Run-length encoding)
91. Compare Version Numbers — 165 (String parsing)
92. Multiply Strings — 43 (String arithmetic)
93. Add Binary — 67 (Binary addition)
94. Repeated DNA Sequences — 187 (Rolling hash)

## More Arrays + Greedy Introduction (95-109)
95. Rotate Array — 189 (Cyclic rotation)
96. Next Permutation — 31 (In-place permutation)
97. Merge Intervals — 56 (Interval merging)
98. Insert Interval — 57 (Interval insertion)
99. Non-overlapping Intervals — 435 (Interval removal)
100. Assign Cookies — 455 (Greedy assignment)
Question 101. Lemonade Change — 860 (Change making)
Question 102. Meeting Rooms — 252 (Overlap check)
Question 103. Jump Game — 55 (Greedy reachability)
Question 104. Jump Game II — 45 (Minimum jumps)
Question 105. Gas Station — 134 (Greedy circuit)
Question 106. Partition Labels — 763 (String partitioning)
Question 107. Minimum Number of Arrows to Burst Balloons — 452 (Interval coverage)
Question 108. Candy — 135 (Two-pass greedy)
Question 109. Queue Reconstruction by Height — 406 (Greedy reconstruction)

---

# Phase 2: Core Structures + Patterns (110-207)

## LinkedList Fundamentals (110-134)
110. Reverse Linked List — 206 (Iterative reversal)
111. Middle of the Linked List — 876 (Fast/slow pointers)
112. Palindrome Linked List — 234 (Middle + reverse)
113. Merge Two Sorted Lists — 21 (Merge operation)
114. Remove Linked List Elements — 203 (Value removal)
115. Delete Node in a Linked List — 237 (Node deletion)
116. Remove Duplicates from Sorted List — 83 (Adjacent duplicates)
117. Linked List Cycle — 141 (Floyd's detection)
118. Linked List Cycle II — 142 (Cycle start)
119. Intersection of Two Linked Lists — 160 (Length difference)
120. Remove Nth Node From End of List — 19 (Two pointers)
121. Rotate List — 61 (Circular connection)
122. Odd Even Linked List — 328 (Position grouping)
123. Partition List — 86 (Two-list approach)
124. Swap Nodes in Pairs — 24 (Pair swapping)
125. Reverse Linked List II — 92 (Sublist reversal)
126. Reorder List — 143 (Middle + reverse + merge)
127. Remove Duplicates from Sorted List II — 82 (All duplicates)
128. Add Two Numbers — 2 (Elementary addition)
129. Add Two Numbers II — 445 (Reverse order)
130. Plus One Linked List — 369 (Increment operation)
131. Sort List — 148 (Merge sort)
132. Insertion Sort List — 147 (Insertion sort)
133. Copy List with Random Pointer — 138 (Deep copy)
134. Flatten a Multilevel Doubly Linked List — 430 (DFS flattening)

## Stack Fundamentals (135-152)
135. Valid Parentheses — 20 (Stack matching)
136. Min Stack — 155 (Auxiliary stack)
137. Implement Queue using Stacks — 232 (Two stacks)
138. Backspace String Compare — 844 (Stack simulation)
139. Remove All Adjacent Duplicates In String — 1047 (Stack removal)
140. Remove All Adjacent Duplicates in String II — 1209 (Count-based removal)
141. Baseball Game — 682 (Stack operations)
142. Evaluate Reverse Polish Notation — 150 (Postfix evaluation)
143. Basic Calculator II — 227 (Operator precedence)
144. Decode String — 394 (Nested decoding)
145. Next Greater Element I — 496 (Monotonic stack)
146. Next Greater Element II — 503 (Circular array)
147. Daily Temperatures — 739 (Temperature tracking)
148. Online Stock Span — 901 (Running span)
149. Sum of Subarray Minimums — 907 (Contribution method)
150. Largest Rectangle in Histogram — 84 (Area calculation)
151. Maximal Rectangle — 85 (2D histogram)
152. Car Fleet — 853 (Position + speed)

## Queue & Heap Basics (153-167)
153. Design Circular Queue — 622 (Circular design)
154. Design Circular Deque — 641 (Deque design)
155. Moving Average from Data Stream — 346 (Window average)
156. Number of Recent Calls — 933 (Time window)
157. Dota2 Senate — 649 (Game simulation)
158. Kth Largest Element in an Array — 215 (Quickselect/heap)
159. Kth Largest Element in a Stream — 703 (Running kth)
160. Last Stone Weight — 1046 (Heap simulation)
161. K Closest Points to Origin — 973 (Distance heap)
162. Top K Frequent Elements — 347 (Frequency heap)
163. Sort Characters By Frequency — 451 (Frequency sort)
164. Find K Pairs with Smallest Sums — 373 (Pair generation)
165. Reorganize String — 767 (Greedy scheduling)
166. Task Scheduler — 621 (CPU scheduling)
167. Meeting Rooms II — 253 (Concurrent tracking)

## Trees - Traversal & Basics (168-192)
168. Binary Tree Inorder Traversal — 94 (Iterative DFS)
169. Binary Tree Preorder Traversal — 144 (Iterative DFS)
170. Binary Tree Postorder Traversal — 145 (Iterative DFS)
171. Binary Tree Level Order Traversal — 102 (BFS basics)
172. Binary Tree Level Order Traversal II — 107 (Bottom-up BFS)
173. Binary Tree Zigzag Level Order Traversal — 103 (Alternating BFS)
174. Binary Tree Right Side View — 199 (Level selection)
175. Average of Levels in Binary Tree — 637 (Level computation)
176. Find Bottom Left Tree Value — 513 (Level tracking)
177. Maximum Depth of Binary Tree — 104 (Recursive DFS)
178. Minimum Depth of Binary Tree — 111 (BFS or DFS)
179. Same Tree — 100 (Structure comparison)
180. Symmetric Tree — 101 (Mirror validation)
181. Invert Binary Tree — 226 (Structure modification)
182. Balanced Binary Tree — 110 (Height checking)
183. Diameter of Binary Tree — 543 (Path through root)
184. Sum of Left Leaves — 404 (Conditional sum)
185. Leaf-Similar Trees — 872 (Leaf sequences)
186. Path Sum — 112 (Root-to-leaf DFS)
187. Path Sum II — 113 (All paths backtracking)
188. Binary Tree Paths — 257 (Path strings)
189. Sum Root to Leaf Numbers — 129 (Number formation)
190. Subtree of Another Tree — 572 (Subtree matching)
191. Merge Two Binary Trees — 617 (Tree merging)
192. Count Good Nodes in Binary Tree — 1448 (Path tracking)

## BST Operations (193-207)
193. Search in a Binary Search Tree — 700 (BST search)
194. Insert into a Binary Search Tree — 701 (BST insertion)
195. Delete Node in a BST — 450 (BST deletion)
196. Validate Binary Search Tree — 98 (BST property)
197. Kth Smallest Element in a BST — 230 (Inorder + count)
198. Minimum Absolute Difference in BST — 530 (Inorder difference)
199. Find Mode in Binary Search Tree — 501 (Frequency tracking)
200. Lowest Common Ancestor of a BST — 235 (BST LCA)
201. Convert Sorted Array to Binary Search Tree — 108 (Balanced construction)
202. Trim a Binary Search Tree — 669 (Range pruning)
203. Range Sum of BST — 938 (Conditional sum)
204. Increasing Order Search Tree — 897 (Flatten BST)
205. Convert BST to Greater Tree — 538 (Reverse inorder)
206. Two Sum IV - Input is a BST — 653 (BST search)
207. Lowest Common Ancestor of a Binary Tree — 236 (General tree LCA)

---

# Phase 3: Advanced Patterns (208-282)

## Graphs - Traversal Basics (208-232)
208. Number of Islands — 200 (Grid DFS)
209. Max Area of Island — 695 (Area calculation)
210. Flood Fill — 733 (Grid modification)
211. Island Perimeter — 463 (Boundary counting)
212. Number of Closed Islands — 1254 (Boundary check)
213. Number of Enclaves — 1020 (Unreachable area)
214. Surrounded Regions — 130 (Boundary DFS)
215. Clone Graph — 133 (Graph deep copy)
216. All Paths From Source to Target — 797 (Path enumeration)
217. Keys and Rooms — 841 (Reachability DFS)
218. Find if Path Exists in Graph — 1971 (Basic connectivity)
219. Find Center of Star Graph — 1791 (Degree analysis)
220. Find the Town Judge — 997 (In/out degree)
221. Number of Provinces — 547 (Connected components)
222. Number of Connected Components in an Undirected Graph — 323 (Component count)
223. Graph Valid Tree — 261 (Tree validation)
224. Is Graph Bipartite? — 785 (2-coloring)
225. Possible Bipartition — 886 (Conflict graph)
226. Pacific Atlantic Water Flow — 417 (Dual-source DFS)
227. Shortest Bridge — 934 (Multi-source BFS)
228. Shortest Path in Binary Matrix — 1091 (Grid BFS)
229. As Far from Land as Possible — 1162 (Multi-source BFS)
230. Rotting Oranges — 994 (Multi-source BFS)
231. Walls and Gates — 286 (Multi-source BFS)
232. Find Eventual Safe States — 802 (Cycle detection)

## Binary Search Complete (233-252)
233. Binary Search — 704 (Template)
234. Search Insert Position — 35 (Insert location)
235. First Bad Version — 278 (Minimize calls)
236. Sqrt(x) — 69 (Integer square root)
237. Valid Perfect Square — 367 (Mathematical)
238. Guess Number Higher or Lower — 374 (Guessing game)
239. Find First and Last Position of Element in Sorted Array — 34 (Range finding)
240. Search in Rotated Sorted Array — 33 (Rotation handling)
241. Find Minimum in Rotated Sorted Array — 153 (Minimum point)
242. Find Peak Element — 162 (Local maximum)
243. Single Element in a Sorted Array — 540 (Parity check)
244. Find Smallest Letter Greater Than Target — 744 (Circular search)
245. Koko Eating Bananas — 875 (Speed optimization)
246. Capacity To Ship Packages Within D Days — 1011 (Capacity optimization)
247. Minimum Number of Days to Make m Bouquets — 1482 (Time optimization)
248. Split Array Largest Sum — 410 (Min-max optimization)
249. Search a 2D Matrix — 74 (2D as 1D)
250. Search a 2D Matrix II — 240 (Staircase search)
251. Kth Smallest Element in a Sorted Matrix — 378 (Matrix search)
252. Find K Closest Elements — 658 (Binary search + expand)

## Union-Find Pattern (253-260)
253. Redundant Connection — 684 (Cycle detection)
254. Friend Circles — 547 (Component count using union-find)
255. Regions Cut By Slashes — 959 (Grid union-find)
256. Accounts Merge — 721 (String union-find)
257. Most Stones Removed with Same Row or Column — 947 (Union optimization)
258. Satisfiability of Equality Equations — 990 (Variable union)
259. Smallest String With Swaps — 1202 (Group swaps)
260. Number of Operations to Make Network Connected — 1319 (Component merging)

## Topological Sort (261-268)
261. Course Schedule — 207 (Cycle detection)
262. Course Schedule II — 210 (Topological order)
263. Minimum Height Trees — 310 (Center finding)
264. Parallel Courses — 1136 (Level-based scheduling)
265. Alien Dictionary — 269 (Lexicographic order)
266. Sequence Reconstruction — 444 (Unique topology)
267. Course Schedule IV — 1462 (Reachability query)
268. Find All Possible Recipes from Given Supplies — 2115 (Dependency resolution)

## Backtracking Complete (269-284)
269. Subsets — 78 (Power set)
270. Subsets II — 90 (With duplicates)
271. Permutations — 46 (All permutations)
272. Permutations II — 47 (With duplicates)
273. Combinations — 77 (K-combinations)
274. Combination Sum — 39 (Unlimited use)
275. Combination Sum II — 40 (Each once)
276. Combination Sum III — 216 (Fixed K numbers)
277. Generate Parentheses — 22 (Valid sequences)
278. Letter Combinations of a Phone Number — 17 (Digit mapping)
279. Palindrome Partitioning — 131 (All partitions)
280. Word Search — 79 (Grid backtracking)
281. N-Queens — 51 (Constraint placement)
282. Letter Case Permutation — 784 (Case combinations)
283. Restore IP Addresses — 93 (Valid segmentation)
284. Beautiful Arrangement — 526 (Position constraints)

---

# Phase 4: Advanced Topics (285-355)

## Advanced Graph Algorithms (285-294)
285. Network Delay Time — 743 (Dijkstra basic)
286. Cheapest Flights Within K Stops — 787 (Bellman-Ford)
287. Path with Maximum Probability — 1514 (Modified Dijkstra)
288. Path With Minimum Effort — 1631 (Grid Dijkstra)
289. Swim in Rising Water — 778 (Binary search + BFS)
290. Word Ladder — 127 (BFS state space)
291. Open the Lock — 752 (BFS transformation)
292. Minimum Cost to Connect All Points — 1584 (MST Prim's)
293. Min Cost to Connect All Points — 1135 (MST Kruskal's)
294. Reconstruct Itinerary — 332 (Eulerian path)

## Bit Manipulation Complete (295-315)
295. Missing Number — 268 (XOR or math)
296. Power of Two — 231 (Bit check)
297. Number of 1 Bits — 191 (Bit counting)
298. Reverse Bits — 190 (Bit reversal)
299. Power of Four — 342 (Bit pattern)
300. Single Number II — 137 (Bit counting)
301. Single Number III — 260 (XOR grouping)
302. Counting Bits — 338 (DP with bits)
303. Hamming Distance — 461 (Bit difference)
304. Find the Duplicate Number — 287 (Floyd's + bit alternative)
305. Sum of Two Integers — 371 (Bitwise addition)
306. Bitwise AND of Numbers Range — 201 (Range AND)
307. Total Hamming Distance — 477 (All pairs distance)
308. Maximum XOR of Two Numbers in an Array — 421 (Trie for bits)
309. Maximum Product of Word Lengths — 318 (Bitmask optimization)
310. UTF-8 Validation — 393 (Bit pattern matching)

## Trie Complete (311-318)
311. Implement Trie (Prefix Tree) — 208 (Trie construction)
312. Design Add and Search Words Data Structure — 211 (Trie with wildcards)
313. Word Search II — 212 (Trie + backtracking)
314. Replace Words — 648 (Prefix replacement)
315. Longest Word in Dictionary — 720 (Prefix building)
316. Prefix and Suffix Search — 745 (Combined search)
317. Short Encoding of Words — 820 (Suffix optimization)
318. Map Sum Pairs — 677 (Trie with values)

## Dynamic Programming (319-342)
319. Climbing Stairs — 70 (Basic DP)
320. House Robber — 198 (Non-adjacent selection)
321. House Robber II — 213 (Circular array)
322. Min Cost Climbing Stairs — 746 (Cost optimization)
323. Maximum Product Subarray — 152 (Min/max tracking)
324. Coin Change — 322 (Unbounded knapsack)
325. Coin Change 2 — 518 (Count combinations)
326. Perfect Squares — 279 (Mathematical DP)
327. Unique Paths — 62 (Grid DP)
328. Unique Paths II — 63 (With obstacles)
329. Minimum Path Sum — 64 (Grid cost)
330. Triangle — 120 (Top-down DP)
331. Maximal Square — 221 (2D optimization)
332. Minimum Falling Path Sum — 931 (Path selection)
333. Dungeon Game — 174 (Reverse DP)
334. Best Time to Buy and Sell Stock with Cooldown — 309 (State machine DP)
335. Longest Common Subsequence — 1143 (Classic LCS)
336. Edit Distance — 72 (String transformation)
337. Distinct Subsequences — 115 (Count subsequences)
338. Longest Palindromic Subsequence — 516 (Interval DP)
339. Palindrome Partitioning II — 132 (Partition DP)
340. Longest Increasing Subsequence — 300 (LIS with binary search)
341. Russian Doll Envelopes — 354 (2D LIS)
342. Delete Operation for Two Strings — 583 (LCS application)

## Design Problems (343-348)
343. LRU Cache — 146 (HashMap + doubly linked list)
344. LFU Cache — 460 (Frequency tracking)
345. Insert Delete GetRandom O(1) — 380 (Array + hashmap)
346. Design Twitter — 355 (Multiple structures)
347. Time Based Key-Value Store — 981 (Versioned storage)
348. Design Underground System — 1396 (Nested hashmap)

## Final Integration & Important Hard Problems (349-355)
349. Trapping Rain Water — 42 (Two pointers/monotonic stack)
350. Minimum Window Substring — 76 (Sliding window template)
351. Binary Tree Maximum Path Sum — 124 (Tree DP)
352. Word Ladder II — 126 (BFS + backtracking)
353. Sudoku Solver — 37 (Backtracking constraints)
354. Serialize and Deserialize Binary Tree — 297 (Tree encoding)
355. Median of Two Sorted Arrays — 4 (Binary search partition)
