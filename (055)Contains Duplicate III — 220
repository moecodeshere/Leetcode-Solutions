class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {
        TreeSet<Long> window= new TreeSet<>();
        for(int i =0;i<nums.length;i++){
            long num=nums[i];
            Long floor= window.floor(num);
            Long cieling= window.ceiling(num);

            if(floor!= null && num-floor<=valueDiff){
                return true;
            }
            if(cieling!=null && cieling-num<=valueDiff){
                return true;
            }
            window.add(num);

            if(i>=indexDiff){
                window.remove((long)nums[i-indexDiff]);
            }
        }
        return false;
    }
}




/*ye galt hai isko sahi krne ke liye , add another for loop jo check every number left of l not just l, so ek brute force type approach hogi fir )
int l=0;
        for(int r=0;r<nums.length;r++){
            while(r-l>indexDiff){
                l++;   
            }
            if(Math.abs(l-r)<=indexDiff && (Math.abs(nums[l] - nums[r]) <= valueDiff) && l!=r)
                return true;
        }
        return false;*/
